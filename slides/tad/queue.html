<link rel="stylesheet" href="css/about_me.css">

<section data-transition="convex">
    <section data-background="images/background-queue.jpg">
        <h2 class="box-shadow-black">Colas</h2>
        <h4 class="box-shadow-black"><code>queue</code></h4>
    </section>

    <section>
        <p>Colección de <span class="blue">elementos homogéneos</span></p>
        <p>Los elementos tienen posisiciones asignadas (hay un orden)</p>
        <p>Puede haber elementos repetidos</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Representación</h4>
        <img src="slides/tad/lista-simple.dot.png" />

    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>🤔 ¿Y en qué se diferencia de una lista?</p>
    </section>
</section>

<section data-transition="convex">
    <section data-background="images/background-queue.jpg">
        <h2 class="box-shadow-black">Colas -vs- Listas</h2>
    </section>

    <section>
        <p>La diferencia entre una lista y una cola son los métodos expuestos para añadir y acceder a los elementos.</p>
    </section>

    <section>
        <p><a href="https://en.cppreference.com/w/cpp/container">cppreference.com - containers library</a></p>
        <img src="slides/tad/container-adaptors.png" />
    </section>

    <section>
        <h4>Encapsulamiento</h4>
        <p class="fragment">Misma implementación</p>
        <p class="fragment">Diferente interfaz</p>
    </section>


    <section>
        <h4>Cola/Queue: FIFO structure</h4>
        <p>First In, First Out</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">        
        <img src="slides/tad/queue-methods.png" />
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Implementación</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
Una cola (`queue`) es una clase con estos métodos

```cpp
class Queue {
    public:
        Queue();

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;

        void push(const TipoDato& dato);
        void pop();
    protected:
        std::shared_ptr<ElementListaDoble> _front = nullptr;
        std::shared_ptr<ElementListaDoble> _back = nullptr;
    };
```
<small>`Queue.h`</small> 

<div class="footnote">Compara con la definición de <a href="https://en.cppreference.com/w/cpp/container/queue">queue en la librería standard</a>.</div>

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Mismos métodos que en una lista, pero otro nombre


| Queue  | DoubleLinkedList |
| ------ | ---------------- |
| front  | front            |
| back   | back             |
| push   | push_back        |
| pop    | pop_front        |

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Queue::push <!-- .element: class="caps-preserve" -->

```cpp
// Inserts an element, it will become the latest in the queue
void Queue::push(const TipoDato& dato) {
    // TODO: Exactly the same implementation 
    //       as DoubleLinkedList::push_back
}
```
<small>`Queue.cpp`</small> 

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Queue::pop <!-- .element: class="caps-preserve" -->

```cpp
// Removes the first element from the queue
void Queue::pop() {
    // TODO: Exactly the same implementation
    //       as DoubleLinkedList::pop_front
}
```
<small>`Queue.cpp`</small> 

        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Queue::front <!-- .element: class="caps-preserve" -->

```cpp
// Removes the first element from the queue
TipoDato& Queue::front() {
    // TODO: Exactly the same implementation
    //       as DoubleLinkedList::front
}
```
<small>`Queue.cpp`</small> 

🚨 Si la cola está vacía el comportamiento será indeterminado (undefined behavior).  <!-- .element: class="footnote" -->
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Queue::back <!-- .element: class="caps-preserve" -->

```cpp
// Removes the first element from the queue
TipoDato& Queue::back() {
    // TODO: Exactly the same implementation
    //       as DoubleLinkedList::back
}
```
<small>`Queue.cpp`</small> 

🚨 Si la cola está vacía el comportamiento será indeterminado (undefined behavior).  <!-- .element: class="footnote" -->
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>¿Por qué existen?</h2>
    </section>

    <section>
        <h2>Encapsulamiento</h2>
        <p>Muestra sólo lo que se va a utilizar</p>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Ejercicios propuestos</h2>
    </section>

    <section>
        <h4>Implementación biblioteca standard</h4>
        <p>Compara tu clase <code>Queue</code> con la ofrecida por la biblioteca standard en <a
                href="https://en.cppreference.com/w/cpp/container/queue"><code>std::queue</code></a>. ¿Se parecen?</p>
        <div class="footnote">
            <p>Pronto aprenderas a utilizar <strong>templates</strong> que generalizar
                las estructuras de datos para cualquier tipo de dato (<code>std::queue&lt;int&gt;</code>,  <code>std::queue&lt;std::string&gt;</code>,...)</p>
        </div>
    </section>

    <section>
        <h4>🙏 Tu propia biblioteca de TADs: queue</h4>
        <p>Reune el código relacionado con las colas en tu ordenador, junto al de las listas</p>
    </section>

    <section>
        <p>Sólo necesitas añadir:</p>
        <ul>
            <li><code>Queue.h</code></li>
            <li><code>Queue.cpp</code></li>
        </ul>
    </section>

    <section data-markdown>
        <script type="text/template">
### Haz muchos ejemplos

Crea pequeños programas utilizando las clases que ya tienes. 
        </script>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>💻 Actividad 10 🌶🌶🌶</h2>
    </section>

    <section>
        <p>¿Por qué siempre te toca la cola más lenta? <a href="https://youtu.be/VPuRoEOVogo"><img data-src="images/youtube-logo.png" class="brand-icon" /></a></p>
        <p>¿Cómo funciona la cola única?</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Métodos de Montecarlo</p>
        <img class="r-stretch" src="slides/tad/montecarlo-pi.gif"/>
        <p>
            <small>
                Existen problemas cuyas entradas son tan complejas o que dependen de tantas variables que su 
                solución sólo se puede calcular mediante simulación.
            </small>
        </p>
    </section>

    <section>
        <p>
            Con el ordenador podemos <strong>simular</strong> el escenario de un supermercado y calcular los
            tiempos de espera medios, la longitud de las colas en las cajas, el número de cajas que hay que
            abrir,...
        </p>
    </section>

    <section data-markdown>
        <script type="text/template">
### Simular el paso del tiempo

Para simular el paso del tiempo utilizamos un bucle y un contador de segundos (`seconds`). 

```cpp
int main() {
    int seconds = 0;
    while (seconds < 10000) {
        // Things will happen here
        // ...

        seconds += 1; // next timestep
    }
}
```
<small>`main.cpp`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Clientes

En nuestra simulación habrá clientes, que tardarán entre `0` y `99` segundos en pasar por caja

```cpp
class Client {
    public:
        Client() {
            // Random number between 0 and 99
            time_to_pay = std::rand() % 100;
        }

    public:
        int time_to_pay;
};
```
<small>`Client.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Podemos simular que aparece un nuevo cliente cada dos minutos

```cpp
int main() {
    int seconds = 0;
    while (seconds < 10000) {
        // ...
        if (seconds % 120 == 0) {
            // ...add the client to a queue
        }

        seconds += 1; // next timestep
    }
}
```
<small>`main.cpp`</small>
<div class="footnote">Sería interesante utilizar una <a href="https://es.wikipedia.org/wiki/Distribuci%C3%B3n_de_Poisson">distribución de Poisson</a> para generar estos eventos.</div>
        </script>
    </section>

    <section>
        <h4>Una cola por caja</h4>
        <p>Los clientes se añaden a la cola más corta</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Tenemos que buscar la cola más corta para añadir los nuevos clientes a ella

```cpp
void add_new_client(std::array<Queue, 4>& lanes) {
    // Creates a new client and add it to the shortest queue
    Client client{};
    int shortest_idx = 0;
    for (int i=0; i<lanes.size(); i++) {
        if (lanes[i].size() < lanes[shortest_idx].size()) {
            shortest_idx = i;
        }
    }
    // Push client to the shortest queue
    lanes[shortest_idx].push(client);
}
```
<small>`main.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Añadimos el evento a nuestra simulación

```cpp
int main() {
    int seconds = 0;
    std::array<Queue, 4> lanes;
    while (seconds < 10000) {
        // ...
        if (seconds % 120 == 0) {
            add_new_client(lanes);
        }
        // ...
        seconds += 1; // next timestep
    }
}
```
<small>`main.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Simulamos el tiempo que tardan en pagar los clientes

```cpp[6-14]
int main() {
    int seconds = 0;
    std::array<Queue, 4> lanes;
    while (seconds < 10000) {
        // ...
        for (auto& lane: lanes) {  // Note the '&'
            if (!lane.empty()) {
                auto& front_client = lane.front(); // Note the '&'
                front_client.time_to_pay--;
                if (front_client.time_to_pay <= 0) {
                    lane.pop();
                }
            }
        }

        // ...
        seconds += 1; // next timestep
    }
}
```
<small>`main.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Recogemos la informacion que nos interesa en cada instante de tiempo, lo [guardamos en un fichero](https://www.cplusplus.com/doc/tutorial/files/).

```cpp[4-5,11-15,20]
#include <fstream>

int main() {
    std::ofstream data;
    data.open("output.txt");

    int seconds = 0;
    std::array<Queue, 4> lanes;
    while (seconds < 10000) {
        // ...
        // Save to file
        int total = 0;
        data << seconds << " ";
        for (auto lane: lanes) {
            data << lane.size() << " ";
            total += lane.size();
        }
        data << total << "\n";

        // ...
        seconds += 1; // next timestep
    }
    data.close();
    return 0;
}
```
<small>`main.cpp`</small>
        </script>
    </section>

    <section>
        <p>Utiliza excel (o cualquier software) para hacer una gráfica en la que se muestre la distribución de personas esperando.</p>
    </section>

    <section>
        <p>Varía los parámetros y observa cómo cambia la distribución: número de cajas, los tiempos de pago, tiempo entre clientes,...</p>
    </section>


    <section>
        <h4>Sistema de cola única</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Existe una única cola a la que se añaden los clientes

```cpp
int main() {
    int seconds = 0;
    Queue clients;
    while (seconds < 10000) {
        // ...
        if (seconds % 120 == 0) {
            clients.push(Client{});
        }
        // ...
        seconds += 1; // next timestep
    }
}
```
<small>`main.cpp`</small>
        </script>
    </section>


    <section data-markdown>
        <script type="text/template">
Las cajas atienden a los clientes uno por uno

```cpp[8-19]
int main() {
    int seconds = 0;
    
    std::array<Client, 4> lanes;

    while (seconds < 10000) {
        // ...
        // Simulate clients paying at the lanes
        for (int i=0; i<lanes.size(); i++) {
            lanes[i].time_to_pay--;
            if (lanes[i].time_to_pay <= 0) {
                // Take next client from the queue
                if (!clients.empty()) {
                    auto front_client = clients.front();
                    clients.pop();
                    lanes[i] = front_client;
                }
            }
        }
        // ...
        seconds += 1; // next timestep
    }
}
```
<small>`main.cpp`</small>
        </script>
    </section>

    <section data-background="slides/tad/queue-single-queue.jpg">
        <h4 class="box-shadow-black">Conclusiones</h4>
    </section>
</section>
