<section data-transition="convex">
    <section data-markdown data-state="darken" data-background="images/backgroup-suitup.jpg">
        <script type="text/template">
La lista ES una `class`

```cpp
class LinkedList {
    ...
};
``` 
<small>`LinkedList.h`</small>
        </script>
    </section>
</section>

<section data-transition="convex">
    <section data-markdown data-state="darken" data-background="images/backgroup-suitup.jpg">
        <script type="text/template">
Cada elemento de la lista es _igual_ que en el caso de funciones libres

```cpp
class ElementListaSimple {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementListaSimple> next = nullptr;
    public:
        // Constructor 
        ElementListaSimple(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementListaSimple.h`</small>
        </script>
    </section>

    <section data-markdown data-state="darken" data-background="images/backgroup-suitup.jpg">
        <script type="text/template">
Cada elemento de la lista es _igual_ que en el caso de funciones libres

```cpp
class ElementListaDoble {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementListaDoble> next = nullptr;
        std::shared_ptr<ElementListaDoble> prev = nullptr;
    public:
        // Constructor 
        ElementListaDoble(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementListaDoble.h`</small>
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Atributos</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista simple

```cpp
class LinkedList {
    public:
        // Lots of methods
    protected:
        // Simple list: only the pointer to the first element
        std::shared_ptr<ElementListaSimple> front;
};
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista doblemente enlazada

```cpp
class DoubleLinkedList {
    public:
        // Lots of methods
    protected:
        // Double linked list: only the pointer to the first element
        std::shared_ptr<ElementListaDoble> front;
};
``` 
Recuerda que los punteros al elemento siguiente/anterior los almacenan los elementos
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista simpele _completa_

A veces es útil tener el puntero al último elemento también

```cpp
class LinkedList {
    public:
        // Lots of methods
    protected:
        std::shared_ptr<ElementListaSimple> front;
        std::shared_ptr<ElementListaSimple> back;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista doble _completa_

A veces es útil tener el puntero al último elemento también

```cpp
class DoubleLinkedList {
    public:
        // Lots of methods
    protected:
        std::shared_ptr<ElementListaDoble> front;
        std::shared_ptr<ElementListaDoble> back;
};
``` 
<small>`DoubleLinkedList.h`</small> 
        </script>
    </section>

</section>

<section>
    <section>
        <h2>Constructores</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
Podemos construirla vacía o empezar con un elemento

```cpp
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        // More methods
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Constructor de una lista vacía

```cpp
LinkedList::LinkedList() : front{nullptr}, back{nullptr} {
}
``` 
<small>`LinkedList.cpp`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Constructor de una lista con un elemento

```cpp
LinkedList::LinkedList(const TipoDato& dato) {
    front = std::make_shared<ElementListaSimple>(ElementListaSimple{dato});
    back = front; // both are pointing to the same element
}
``` 
<small>`LinkedList.cpp`</small> 
        </script>
    </section>
</section>

<section>
    <section>
        <h2>Métodos<h2>
    </section>

    <section>
        <h4>Iterar la lista</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Declaración de los métodos en `LinkedList.h`
```cpp
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementación en `LinkedList.cpp`
```cpp
void LinkedList::for_each(std::function<void (TipoDato&)> action) const {
    // Iterate the list as usual
    std::shared_ptr<ElementListaSimple> iterator = front;
    while (iterator != nullptr) {
        action(iterator->dato); // Call the action
        iterator = iterator->next;
    }
}

void LinkedList::enumerate(std::function<void (int, TipoDato&)> action) const {
    // Iterate the list as usual
    std::shared_ptr<ElementListaSimple> iterator = front;
    int idx = 0;
    while (iterator != nullptr) {
        action(idx, iterator->dato); // Call the action
        iterator = iterator->next;
        idx++;
    }
}
``` 
<small>`LinkedList.cpp`</small> 
        </script>
    </section>

    <section>
        <h4>Tamaño de la lista</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Declaración de los métodos en `LinkedList.h`
```cpp[9-10]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementación en `LinkedList.cpp`
```cpp[9-10]
int LinkedList::size() const {
    // Implementation
}
bool LinkedList::empty() const {
    // Implementation
}
``` 
<small>`LinkedList.cpp`</small> 

Inspiración en [el capítulo anterior](07.lists-free-functions.html). 
<!-- .element: class="fragment" -->
        </script>
    </section>

    <section>
        <h4>Acceso</h4>
    </section>

    <section data-markdown>
        <script type="text/template">

```cpp[12-14]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Inserción</h4>
    </section>

    <section data-markdown>
        <script type="text/template">

```cpp[16-18]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Borrado</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[20-23]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);

        void pop_back();
        void pop_front();
        void clear();
        void erase(int pos);
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Otras operaciones</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[25-26]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);

        void pop_back();
        void pop_front();
        void clear();
        void erase(int pos);

        void swap(int pos1, int pos2);
        int search(const TipoDato& dato) const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Ordenación</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[28-29]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);

        void pop_back();
        void pop_front();
        void clear();
        void erase(int pos);

        void swap(int pos1, int pos2);
        int search(const TipoDato& dato) const;

        void sort();
        bool is_sorted() const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>
</section>

<section data-external-slide-replace="slides/tad/lista-doble.html"></section>


<section data-transition="convex">
    <section>
        <h2>Ejercicios propuestos</h2>
    </section>

    <section>
        <h4>Implementación biblioteca standard</h4>
        <p>Compara tu clase <code>LinkedList</code> con la ofrecida por la biblioteca standard en <a
                href="https://en.cppreference.com/w/cpp/container/list"><code>std::list</code></a>. ¿Se parecen?</p>
        <div class="footnote">
            <p>Pronto aprenderas a utilizar <strong>templates</strong> que generalizar
                las estructuras de datos para cualquier tipo de dato (<code>std::list&lt;int&gt;</code>,  <code>std::list&lt;std::string&gt;</code>,...)</p>
        </div>
    </section>

    <section>
        <h4>Tu propia biblioteca de TADs: listas</h4>
        <p>Reune el código relacionado con las listas en tu ordenador</p>
    </section>

    <section>
        <p>Necesitas almacenar datos:</p>
        <ul>
            <li><code>TipoDato.h</code></li>
            <li><code>TipoDato.cpp</code></li>
        </ul>
    </section>

    <section data-markdown>
        <script type="text/template">
Ejemplo de `TipoDato`: interfaz

```cpp
#include <string>

struct TipoDato {
    std::string film;
    int year;
    int number_stars;
};

// A function to define order
bool less_than(const TipoDato& lhs, const TipoDato& rhs);

// A function to compare two instances
bool equal(const TipoDato& lhs, const TipoDato& rhs);
``` 
<small>`TipoDato.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Ejemplo de `TipoDato`: implementación

```cpp
#include "TipoDato.h"

// A function to define order
bool less_than(const TipoDato& lhs, const TipoDato& rhs) {
    return lhs.year < rhs.year;  // Order by year
}

// A function to compare two instances
bool equal(const TipoDato& lhs, const TipoDato& rhs) {
    // Two films are equal if the have the same name and year.
    return (lhs.film == rhs.film) && (lhs.year == rhs.year);
}
``` 
<small>`TipoDato.h`</small> 
        </script>
    </section>

    <section>
        <p>Código relacionado con <code>LinkedList</code>:</p>
        <ul>
            <li><code>ElementListaSimple.h</code></li>
            <li><code>LinkedList.h</code></li>
            <li><code>LinkedList.cpp</code></li>
        </ul>
    </section>

    <section>
        <p>Añade la <code>DoubleLinkedList</code> a tu biblioteca:</p>
        <ul>
            <li><code>ElementListaDoble.h</code></li>
            <li><code>DoubleLinkedList.h</code></li>
            <li><code>DoubleLinkedList.cpp</code></li>
        </ul>
    </section>


    <section data-markdown>
        <script type="text/template">
### Haz muchos ejemplos

Crea pequeños programas utilizando las clases que ya tienes.

```cpp
#include "LinkedList.h"

int main() {
    LinkedList films;
    films.push_back(TipoDato{"Citizen Kane", 1941, 5});
    films.push_back(TipoDato{"Into the wild", 2007, 5});
    // ... add more films

    films.sort();
    films.for_each([](TipoDato& dato) { std::cout << dato.film << std::endl; });
}
``` 
        </script>
    </section>

    <section data-background="images/programmer-247.jpg">
    </section>
</section>
