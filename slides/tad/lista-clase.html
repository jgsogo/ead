<section data-transition="convex">
    <section data-markdown data-state="darken" data-background="images/backgroup-suitup.jpg">
        <script type="text/template">
La lista ES una `class`

```cpp
class LinkedList {
    ...
};
``` 
<small>`LinkedList.h`</small>
        </script>
    </section>
</section>

<section data-transition="convex">
    <section data-markdown data-state="darken" data-background="images/backgroup-suitup.jpg">
        <script type="text/template">
Cada elemento de la lista es _igual_ que en el caso de funciones libres

```cpp
class ElementListaSimple {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementListaSimple> next = nullptr;
    public:
        // Constructor 
        ElementListaSimple(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementListaSimple.h`</small>
        </script>
    </section>

    <section data-markdown data-state="darken" data-background="images/backgroup-suitup.jpg">
        <script type="text/template">
Cada elemento de la lista es _igual_ que en el caso de funciones libres

```cpp
class ElementListaDoble {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementListaDoble> next = nullptr;
        std::shared_ptr<ElementListaDoble> prev = nullptr;
    public:
        // Constructor 
        ElementListaDoble(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementListaDoble.h`</small>
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Atributos</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista simple

```cpp
class LinkedList {
    public:
        // Lots of methods
    protected:
        // Simple list: only the pointer to the first element
        std::shared_ptr<ElementListaSimple> front;
};
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista doblemente enlazada

```cpp
class DoubleLinkedList {
    public:
        // Lots of methods
    protected:
        // Double linked list: only the pointer to the first element
        std::shared_ptr<ElementListaDoble> front;
};
``` 
Recuerda que los punteros al elemento siguiente/anterior los almacenan los elementos
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista simpele _completa_

A veces es útil tener el puntero al último elemento también

```cpp
class LinkedList {
    public:
        // Lots of methods
    protected:
        std::shared_ptr<ElementListaSimple> front;
        std::shared_ptr<ElementListaSimple> back;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### Lista doble _completa_

A veces es útil tener el puntero al último elemento también

```cpp
class DoubleLinkedList {
    public:
        // Lots of methods
    protected:
        std::shared_ptr<ElementListaDoble> front;
        std::shared_ptr<ElementListaDoble> back;
};
``` 
<small>`DoubleLinkedList.h`</small> 
        </script>
    </section>

</section>

<section>
    <section>
        <h2>Constructores</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
Podemos construirla vacía o empezar con un elemento

```cpp
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        // More methods
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Constructor de una lista vacía

```cpp
LinkedList::LinkedList() : front{nullptr}, back{nullptr} {
}
``` 
<small>`LinkedList.cpp`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Constructor de una lista con un elemento

```cpp
LinkedList::LinkedList(const TipoDato& dato) {
    front = std::make_shared<ElementListaSimple>(ElementListaSimple{dato});
    back = front; // both are pointing to the same element
}
``` 
<small>`LinkedList.cpp`</small> 
        </script>
    </section>
</section>

<section>
    <section>
        <h2>Métodos<h2>
    </section>

    <section>
        <h4>Iterar la lista</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Declaración de los métodos en `LinkedList.h`
```cpp
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementación en `LinkedList.cpp`
```cpp
void LinkedList::for_each(std::function<void (TipoDato&)> action) const {
    // Iterate the list as usual
    std::shared_ptr<ElementListaSimple> iterator = front;
    while (iterator != nullptr) {
        action(iterator->dato); // Call the action
        iterator = iterator->next;
    }
}

void LinkedList::enumerate(std::function<void (int, TipoDato&)> action) const {
    // Iterate the list as usual
    std::shared_ptr<ElementListaSimple> iterator = front;
    int idx = 0;
    while (iterator != nullptr) {
        action(idx, iterator->dato); // Call the action
        iterator = iterator->next;
        idx++;
    }
}
``` 
<small>`LinkedList.cpp`</small> 
        </script>
    </section>

    <section>
        <h4>Tamaño de la lista</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Declaración de los métodos en `LinkedList.h`
```cpp[9-10]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementación en `LinkedList.cpp`
```cpp[9-10]
int LinkedList::size() const {
    // Implementation
}
bool LinkedList::empty() const {
    // Implementation
}
``` 
<small>`LinkedList.cpp`</small> 

Inspiración en [el capítulo anterior](07.lists-free-functions.html). 
<!-- .element: class="fragment" -->
        </script>
    </section>

    <section>
        <h4>Acceso</h4>
    </section>

    <section data-markdown>
        <script type="text/template">

```cpp[12-14]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Inserción</h4>
    </section>

    <section data-markdown>
        <script type="text/template">

```cpp[16-18]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Borrado</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[20-23]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);

        void pop_back();
        void pop_front();
        void clear();
        void erase(int pos);
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Otras operaciones</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[25-26]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);

        void pop_back();
        void pop_front();
        void clear();
        void erase(int pos);

        void swap(int pos1, int pos2);
        int find(const TipoDato& dato) const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>

    <section>
        <h4>Ordenación</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[28-29]
class LinkedList {
    public:
        LinkedList();
        LinkedList(const TipoDato&);

        void for_each(std::function<void (TipoDato&)> action) const;
        void enumerate(std::function<void (int, TipoDato&)> action) const;

        int size() const;
        bool empty() const;

        TipoDato& front() const;
        TipoDato& back() const;
        TipoDato& at(int pos) const;

        void push_back(const TipoDato& dato);
        void push_front(const TipoDato& dato);
        void insert(const TipoDato& dato, int pos);

        void pop_back();
        void pop_front();
        void clear();
        void erase(int pos);

        void swap(int pos1, int pos2);
        int find(const TipoDato& dato) const;

        void sort();
        bool is_sorted() const;
    protected:
        std::shared_ptr<ElementListaSimple> front = nullptr;
        std::shared_ptr<ElementListaSimple> back = nullptr;
};
``` 
<small>`LinkedList.h`</small> 
        </script>
    </section>
</section>

<section data-external-slide-replace="slides/tad/lista-doble.html"></section>


<section data-transition="convex">
    <section>
        <h2>Ejercicios propuestos</h2>
    </section>

    <section>
        <h4>Implementación biblioteca standard</h4>
        <p>Compara tu clase <code>LinkedList</code> con la ofrecida por la biblioteca standard en <a
                href="https://en.cppreference.com/w/cpp/container/list"><code>std::list</code></a>. ¿Se parecen?</p>
        <div class="footnote">
            <p>Pronto aprenderas a utilizar <strong>templates</strong> que generalizar
                las estructuras de datos para cualquier tipo de dato (<code>std::list&lt;int&gt;</code>,  <code>std::list&lt;std::string&gt;</code>,...)</p>
        </div>
    </section>

    <section>
        <h4>🙏 Tu propia biblioteca de TADs: listas</h4>
        <p>Reune el código relacionado con las listas en tu ordenador</p>
    </section>

    <section>
        <p>Necesitas almacenar datos:</p>
        <ul>
            <li><code>TipoDato.h</code></li>
            <li><code>TipoDato.cpp</code></li>
        </ul>
    </section>

    <section data-markdown>
        <script type="text/template">
Ejemplo de `TipoDato`: interfaz

```cpp
#include <string>

struct TipoDato {
    std::string film;
    int year;
    int number_stars;
};

// A function to define order
bool less_than(const TipoDato& lhs, const TipoDato& rhs);

// A function to compare two instances
bool equal(const TipoDato& lhs, const TipoDato& rhs);
``` 
<small>`TipoDato.h`</small> 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Ejemplo de `TipoDato`: implementación

```cpp
#include "TipoDato.h"

// A function to define order
bool less_than(const TipoDato& lhs, const TipoDato& rhs) {
    return lhs.year < rhs.year;  // Order by year
}

// A function to compare two instances
bool equal(const TipoDato& lhs, const TipoDato& rhs) {
    // Two films are equal if the have the same name and year.
    return (lhs.film == rhs.film) && (lhs.year == rhs.year);
}
``` 
<small>`TipoDato.h`</small> 
        </script>
    </section>

    <section>
        <p>Código relacionado con <code>LinkedList</code>:</p>
        <ul>
            <li><code>ElementListaSimple.h</code></li>
            <li><code>LinkedList.h</code></li>
            <li><code>LinkedList.cpp</code></li>
        </ul>
    </section>

    <section>
        <p>Añade la <code>DoubleLinkedList</code> a tu biblioteca:</p>
        <ul>
            <li><code>ElementListaDoble.h</code></li>
            <li><code>DoubleLinkedList.h</code></li>
            <li><code>DoubleLinkedList.cpp</code></li>
        </ul>
    </section>


    <section data-markdown>
        <script type="text/template">
### Haz muchos ejemplos

Crea pequeños programas utilizando las clases que ya tienes.

```cpp
#include "LinkedList.h"

int main() {
    LinkedList films;
    films.push_back(TipoDato{"Citizen Kane", 1941, 5});
    films.push_back(TipoDato{"Into the wild", 2007, 5});
    // ... add more films

    films.sort();
    films.for_each([](TipoDato& dato) { std::cout << dato.film << std::endl; });
}
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Imprime las películas que correspondan al siglo XX.

```cpp
#include "LinkedList.h"

int main() {
    LinkedList films;
    films.push_back(TipoDato{"Citizen Kane", 1941, 5});
    films.push_back(TipoDato{"Into the wild", 2007, 5});
    // ... add more films

    films.for_each([](TipoDato& dato) { 
        if (dato.year > 2000) {
            std::cout << dato.film << std::endl; 
        }
    });
}
``` 
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Elimina las películas con menos de 3 estrellas.

```cpp
#include "LinkedList.h"

int main() {
    LinkedList films;
    films.push_back(TipoDato{"Citizen Kane", 1941, 5});
    films.push_back(TipoDato{"Into the wild", 2007, 5});
    // ... add more films

    // Store the 'positions' of those films
    std::vector<int> positions;
    films.enumerate([](int pos, TipoDato& dato) { 
        if (dato.number_stars < 3) {
            positions.push_back(pos);
        }
    });

    // Now remove the films at those positions
    // ATTENTION!!! Why we need to iterate in reverse order?
    for (int i = positions.size(); i>0; i--) {
        int pos = positions.at(i-1);
        films.erase(pos);
    }

    // Print and check
}
``` 
        </script>
    </section>

    <section data-background="images/programmer-247.jpg">
    </section>
</section>


<section data-transition="convex">
    <section data-background="images/background-actividades.png">
        <h2>Actividades</h2>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>💻 Actividad 04 🌶</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
**Añade** una función a tu clase `DoubleLinkedList` para iterar la lista desde el final al principio

```cpp
class DoubleLinkedList {
    public:
        // ...
        void for_each_reverse(std::function<void (TipoDato&)> action) const;
        // ...
}
``` 
<small>`DoubleLinkedList.h`</small>
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>💻 Actividad 05 🌶</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
**Añade** una función a tu clase `DoubleLinkedList` para buscar un elemento utilizando un criterio cualquiera

```cpp
class DoubleLinkedList {
    public:
        // ...
        // Returns the index to the FIRST element that satisfies the criteria
        int find(std::function<bool (TipoDato&)> action) const;
        
        // Returns the index to the LAST element that satisfies the criteria
        int find_last_of(std::function<bool (TipoDato&)> action) const;
}
``` 
<small>`DoubleLinkedList.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Ejemplo de uso:

```cpp
int main() {
    DoubleLinkedList personas{};
    // ...

    // Search for a person 33 years old in 2020 (using lambdas!)
    int idx = personas.find([](TipoDato& dato) {
        int birth_date = dato.get_birth_date();
        return (2020 - birth_date == 33);
    });

    TipoDato found = personas.at(idx);
}
``` 
<small>`DoubleLinkedList.h`</small>
        </script>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>💻 Actividad 06 🌶🌶🌶</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
Si nuestro `TipoDato` es una clase con preguntas como un Trivial

```cpp
class Pregunta {
    private:
        std::string pregunta;
        std::string categoria;
        std::array<std::string, 4> respuestas;
        int respuesta_correcta;

    public:
        Pregunta();

        // Add other methods that are needed (getters, setters,...)
};

```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Vamos a añadir unas funciones que nos permitan buscar en la lista utilizando un criterio cualquiera.

```cpp
class DoubleLinkedList {
    public:
        // ...
        // Returns the index to the FIRST element that satisfies the criteria
        int find(std::function<bool (TipoDato&)> action) const;
        
        // Returns the index to the LAST element that satisfies the criteria
        int find_last_of(std::function<bool (TipoDato&)> action) const;
        // ...
}
``` 
<small>`DoubleLinkedList.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Estas funciones podríamos utilizarlas como sigue:

```cpp[9-15]
#include "DoubleLinkedList.h"

int main() {
    DoubleLinkedList preguntas{};
    preguntas.push_back(....);
    preguntas.push_back(....);
    //...

    std::string categoria = "historia";
    auto q_historia = [&](TipoDato& dato) { 
        return dato.categoria == categoria;
    };

    int idx_historia = preguntas.find(q_historia);
    auto q = preguntas.at(idx_historia);

    // Show the question to the user with the possible answers:
    std::cout << q.pregunta << std::endl;
    for (auto respuesta: q.respuestas) {
        std::cout << respuesta << std::endl;
    }

}
``` 
<small>`LinkedList.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
 * Construye una lista con datos del tipo `Pregunta` <sup>(1)<sup>
 * Construye un vector con las diferentes categorías <sup>(2)<sup>
 * Pide al usuario que seleccione una categoría
 * Busca una pregunta de esa categoría en tu lista
 * Muestra la pregunta y sus respuestas
 * Recoge y valida la respuesta del usuario
 * Si es correcta, elimina la pregunta de la lista
 * ... y vuelta a empezar 
 
(1) Consejo: guarda las preguntas en un fichero de texto y léelo al empezar el programa.  <!-- .element: class="footnote" -->

(2) Consejo: puedes construir este vector con las categorías de las preguntas que vas leyendo.  <!-- .element: class="footnote" -->
        </script>
    </section>

</section>
