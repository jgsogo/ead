<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Árboles AVL</h2>
        <h4>(Adelson-Velskii y Landis)</h4>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Propiedades</h2>
        <h4>(Árboles AVL)</h4>
    </section>

    <section>
        <p>
            Los <span class="red">árboles AVL</span> son árboles BB donde todo nodo cumple la propiedad de <span
                class="red">equilibrado AVL</span>.
        </p>
    </section>

    <section>
        <h4>Equilibrado AVL</h4>
        <p>
            La altura del subárbol izquierdo y del subárbol derecho no se diferencian en más de una unidad.
        </p>
    </section>


    <section>
        <h4>Factor de equilibrio</h4>
        <p>
            Definimos <span class="red">factor de equilibrio</span> a la diferencia entre la altura del subárbol derecho
            y el surárbol izquierdo:
        </p>
        <p><code>Fe(nodo) = h(derecho) - h(izquierdo)</code></p>
    </section>

    <section>
        <p>En un árbol AVL el factor de equilibrio de todo nodo será -1, 0 o +1</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-example.dot.png" />
        <p><small>Ejemplo árbol AVL (el factor de equilibrado se indica en cada nodo)</small></p>
    </section>

    <section>
        <p>Tras la inserción o borrado de un elemento los <span>ascendientes</span> del nodo pueden sufrir cambios en su
            factor de equilibrio.</p>
        <p class="fragment">Estos cambios, como mucho, serán de una unidad.</p>
        <p class="fragment">El reequilibrado se realiza mediante <span class="red">rotaciones</span>.</p>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Operaciones</h2>
        <h4>(Árboles AVL)</h4>
    </section>

    <section>
        <h4>Operaciones de acceso</h4>
        <p>Las <span class="blue">operaciones de acceso</span> (altura, tamaño, búsqueda, recorrido) son idénticas a las
            de un árbol BB.</p>
    </section>

    <section>
        <h4>Inserción y borrado</h4>
        <p>Estas operaciones se realizan igual que en un árbol BB, pero se añade una etapa posterior de <span
                class="red">reequilibrado</span>.</p>
    </section>

    <section>
        <h4>Reequilibrado</h4>
        <p>
            El <span class="red">reequilibrado</span> recorre los ascendientes del nodo que ha sufrido modificación,
            recalcula sus factores de equilibrio y aplica las <span class="red">rotaciones</span> adecuadas cuando
            sea necesario.
        </p>
        <p>
            El recorrido se detiene en el <span class="blue">nodo raíz</span> o bien cuando el nodo actual no
            haya sufrido <span class="red">cambios en altura</span>.
        </p>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Cambios en altura</h2>
        <h4>(Árboles AVL)</h4>
    </section>

    <section>
        <h4>Al insertar un nodo</h4>
        <p>
            Un nodo con <span class="blue">factor de equilibrio -1 ó 0</span> incrementará su altura
            si su <span class="blue">hijo izquierdo</span> incrementa su altura.
        </p>
        <hr />
        <p>
            Si el <span class="blue">factor de equilibrio es 0 ó +1</span> incrementará su altura cuando lo haga su
            <span class="blue">hijo derecho</span>.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Cambios en altura al insertar un nodo</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-height-inc.png" />
    </section>

    <section>
        <h4>Al eliminar un nodo</h4>
        <p>
            Un nodo con <span class="blue">factor de equilibrio -1</span> decrementará su altura
            si su <span class="blue">hijo izquierdo</span> decrementa su altura.
        </p>
        <hr />
        <p>
            Si el <span class="blue">factor de equilibrio es +1</span> decrementará su altura cuando lo haga su <span
                class="blue">hijo derecho</span>.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Cambios en altura al eliminar un nodo</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-height-dec.png" />
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Rotaciones</h2>
        <h4>(Árboles AVL)</h4>
    </section>

    <section>
        <p>
            Una <span class="red">rotación</span> es una reestructuración local de un subárbol BB que mantiene la
            propiedad de ordenación.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Rotación izquierda</p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example1-izq.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example1-der.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Ejemplo de rotación. A, B, C representan subárboles equilibrados de altura h.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Rotación izquierda</p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-izq.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-mid.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Ejemplo de rotación. A, B, C, D representan subárboles equilibrados de altura h.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-mid.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-der.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Ejemplo de rotación. A, B, C, D representan subárboles equilibrados de altura h.</small></p>
    </section>

    <section>
        <h4>Objetivo</h4>
        <p>
            El objetivo de las rotaciones siempre es reequilibrar un subárbol que se ha desequilibrado al añadir
            o al eliminar un nodo.
        </p>
    </section>

    <section>
        <h4>Rotación izquierda</h4>
        <h6>-2|-1 &nbsp;&nbsp;&nbsp; -2|0</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Aplicamos una <span class="blue">rotación izquierda</span> cuando encontramos una de estas situaciones
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small>A incrementó su altura o C disminuyó su altura</small>
                </td>
                <td>
                    <small>C disminuyó su altura</small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 1) Tras la <span class="blue">rotación izquierda</span> hay un cambio de altura en este subárbol
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(A) + 2</code><br/>
                        <code>h(A) = h(B) + 1</code><br/>
                        <code>h(C) = h(B)</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(h(A), 1 + max(h(B), h(C)))</code><br/>
                        <code>h(y) = 1 + max(h(A), 1 + h(B))</code><br/>
                        <code>h(y) = 1 + h(A)</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 2) Tras la <span class="blue">rotación izquierda</span> el subárbol mantiene su altura
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda2.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda2-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(A) + 2</code><br/>
                        <code>h(B) = h(A)</code><br/>
                        <code>h(C) = h(A) - 1</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(h(A), 1 + max(h(B), h(C)))</code><br/>
                        <code>h(y) = 1 + max(h(A), 1 + h(B))</code><br/>
                        <code>h(y) = 1 + max(h(A), 1 + h(A))</code><br/>
                        <code>h(y) = 2 + h(A)</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>


    <section>
        <h4>Rotación derecha</h4>
        <h6>2|1 &nbsp;&nbsp;&nbsp; 2|0</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Aplicamos una <span class="blue">rotación derecha</span> cuando encontramos una de estas situaciones
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small>A decrementó su altura o C incrementó su altura</small>
                </td>
                <td>
                    <small>A disminuyó su altura</small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 1) Tras la <span class="blue">rotación derecha</span> hay un cambio de altura en este subárbol
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(C) + 2</code><br/>
                        <code>h(B) = h(C) - 1</code><br/>
                        <code>h(A) = h(C) - 1</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(1 + max(h(A), h(B)), h(C))</code><br/>
                        <code>h(y) = 1 + max(1 + h(A), h(C))</code><br/>
                        <code>h(y) = 1 + h(C)</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 2) Tras la <span class="blue">rotación derecha</span> el subárbol mantiene su altura
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha2.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha2-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(C) + 2</code><br/>
                        <code>h(B) = h(C)</code><br/>
                        <code>h(A) = h(C) - 1</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(1 + max(h(A), h(B)), h(C))</code><br/>
                        <code>h(y) = 1 + max(1 + h(B), h(C))</code><br/>
                        <code>h(y) = 2 + h(C)<code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section>
        <h4>Rotación derecha-izquierda</h4>
        <h6>-2|1</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Aplicamos una <span class="blue">rotación derecha-izquierda</span> cuando encontramos esta situación</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda.dot.png" />
        <p><small>Causas: borrado en D o inserción en B ó C incrementando la altura de <code>z</code>.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 1) <span class="blue">rotación derecha</span> en los nodos <code>y</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda-fix1.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(B), h(C))</code><br/>
                        <code>h(A) = max(h(B), h(C))</code><br/>
                        <code>h(D) = max(h(B), h(C))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(A), h(B))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 2) <span class="blue">rotación izquierda</span> en los nodos <code>x</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda-fix1.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda-fix2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(A), h(B))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(z) = 2 + max(h(A), h(B), h(C), h(D))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section>
        <h4>Rotación izquierda-derecha</h4>
        <h6>2|-1</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Aplicamos una <span class="blue">rotación izquierda-derecha</span> cuando encontramos esta situación</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha.dot.png" />
        <p><small>Causas: borrado en A o inserción en B ó C incrementando la altura de <code>z</code>.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 1) <span class="blue">rotación izquierda</span> en los nodos <code>y</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha-fix1.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(B), h(C))</code><br/>
                        <code>h(A) = max(h(B), h(C))</code><br/>
                        <code>h(D) = max(h(B), h(C))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(C), h(D))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 2) <span class="blue">rotación derecha</span> en los nodos <code>x</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha-fix1.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha-fix2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(C), h(D))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(z) = 2 + max(h(A), h(B), h(C), h(D))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Implementación C++</h2>
        <h4>(Árboles AVL)</h4>
    </section>

    <section>
        <p>
            En lo fundamental la implementación es igual que en un <code>BinarySearchTree</code>, añadiendo
            lo necesario para la operación de reequilibrado (factor de equilibrio, rotaciones,...).
        </p>
    </section>

    <section data-markdown>
        <script type="text/template">
### `AVLTree.h`

```cpp
class AVLTree {
    public:
        AVLTree();

        // ... same as BinarySearchTree
        
    private:
        void rebalance(); // Function to call after every insertion/removal
};
```
<small>`AVLTree.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `AVLTree::push`

Después de insertar el elemento, rebalanceamos

```cpp
void AVLTree::push(const TipoDato& dato) {
    _push(root, dato);
    rebalance();
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `AVLTree::remove`

Después de eliminar el elemento, rebalanceamos

```cpp
void AVLTree::remove(const TipoDato& dato) {
    // ... same as BinarySearchTree::remove

    // After everything is done, rebalance
    rebalance();
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section>
        <h4><code>AVLTree::rebalance</code></h4>
        <p>
            ⚠️ La implementación que se muestra a continuación para el <span class="blue">rebalanceo</span> 
            no es la mejor ni la más eficiente, se ha primado la simplicidad.
        </p>
    </section>

    <section>
        <p>Estrategia:</p>
        <ul>
            <li>Primero hijos, luego padres: <code>dfs_postorder</code>.</li>
            <li>Actuamos cuando el fator de equilibrio es -2 ó 2.</li>
        </ul>
    </section>

    <section data-markdown>
        <script type="text/template">
`AVLTree::rebalance`

Después de eliminar el elemento, rebalanceamos

```cpp[26-30|1-8|10-23]
void _rebalance(std::shared_ptr<ElementoArbolBinario>& element) { // Note the reference
    // DFS post-order strategy:
    if (element->left) {
        _rebalance(element->left);
    }
    else if (element->right) {
        _rebalance(element->right);
    }

    if (factor_equilibrio(element) == -2) {
        if (factor_equilibrio(element->left) == 1) {
            // First, rotate the child right
            rotate_right(element->left);
        }
        rotate_left(element);
    }
    else if (factor_equilibrio(element) == 2) {
        if (factor_equilibrio(element->right) == -1) {
            // First, rotate the child left
            rotate_left(element->right);
        }
        rotate_right(element);
    }
}

void AVLTree::rebalance() {
    if (root != nullptr) {
        _rebalance(root);
    }
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Función auxiliar `factor_equilibrio`:

```cpp
int factor_equilibrio(std::shared_ptr<ElementoArbolBinario> element) {
    return _height(element->right) - _height(element->left);
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Función auxiliar `rotate_left`:

```cpp
void rotate_left(std::shared_ptr<ElementoArbolBinario>& element) { // Note the reference
    auto old_parent = element;
    element = element->left;
    old_parent->left = element->right;
    element->right = old_parent;
}
```
<small>`AVLTree.cpp`</small>
<table>
    <tr>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1.dot.png" />
        </td>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1-fix.dot.png" />
        </td>
    </tr>
</table>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Función auxiliar `rotate_right`:

```cpp
void rotate_right(std::shared_ptr<ElementoArbolBinario>& element) { // Note the reference
    auto old_parent = element;
    element = element->right;
    old_parent->right = element->left;
    element->left = old_parent;
}
```
<small>`AVLTree.cpp`</small>
<table>
    <tr>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1.dot.png" />
        </td>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1-fix.dot.png" />
        </td>
    </tr>
</table>
        </script>
    </section>

    <section>
        <h4><code>AVLTree::rebalance</code> (optimización)</h4>
        <p>
            Todos los rebalanceos (si existen) ocurren en los <span class="blue">ascendientes</span> del nodo que se acaba de
            insertar o de borrar.
        </p>
        <hr/>
        <p class="fragment">
            En vez de realizar un recorrido DFS post-order podríamos almacenar en cada nodo el puntero al padre y utilizarlo
            para recorrer los ascendientes.
        </p>
    </section>
</section>


<section data-transition="convex">
    <section data-background="images/background-actividades.png">
        <h2>Ejercicios propuestos</h2>
    </section>

    <section>
        <h4>🙏 Tu propia biblioteca de TADs: avl_tree</h4>
        <p>Reune el código relacionado con los árboles BB en tu ordenador, junto al de otros TAD</p>
    </section>

    <section>
        <p>Necesitarás añadir:</p>
        <ul>
            <li><code>AVLTree.h</code></li>
            <li><code>AVLTree.cpp</code></li>
        </ul>
    </section>

    <section>
        <p>Haz ejemplos con esta clase, asegúrate de que sus métodos funcionan para todos los escenarios posibles.</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementa una función para realizar el recorrido DFS postorder en el `AVLTree` que acepte nodos del árbol en su función _lambda_

```cpp
class AVLTree {
    public:
        AVLTree();

        // ...
        
    private:
        void dfs_postorder(std::function<void (std::shared_ptr<ElementoArbolBinario>&)> action) const;
};
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementa el método `AVLTree::rebalance` utilizando la función `AVLTree::dfs_postorder` anterior:

```cpp
void AVLTree::rebalance() {
    // This is the action we will execute on every node
    std::function<void (std::shared_ptr<ElementoArbolBinario>&)> action = [](std::shared_ptr<ElementoArbolBinario>& elem) {
        if (factor_equilibrio(elem) == -2) {
            // TODO
        }
        else if (factor_equilibrio(elem) == 2) {
            // TODO
        }
    };

    // Traverse the tree using DFS post-order strategy
    dfs_postorder(action);
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>
</section>