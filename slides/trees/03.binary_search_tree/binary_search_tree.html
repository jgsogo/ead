<section data-transition="convex">
    <section data-state="darken" data-background="slides/trees/03.binary_search_tree/background-bst.png">
        <h2>Definici칩n</h2>
    </section>

    <section>
        <h4>츼rbol binario de b칰squeda (치rbol BB)</h4>
        <p>
            Un <span class="red">치rbol binario de b칰squeda</span> (치rbol BB) es un <span class="blue">치rbol
                binario</span> cuyos elementos
            almacenan datos comparables y todo nodo cumple la <span class="blue">propiedad de ordenaci칩n</span>.
        </p>
    </section>

    <section>
        <h4>Propiedad de ordenaci칩n</h4>
        <p>
            Todo nodo es mayor que los nodos de su sub치rbol izquierdo y menor que los nodos de su sub치rbol derecho.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/03.binary_search_tree/binary_search_tree_example-schema.dot.png" />
        <p><small>Todos los nodos del sub치rbol izquierdo son menores que <code>x</code>, los del sub치rbol derecho
                mayores que <code>x</code>.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/03.binary_search_tree/binary_search_tree_example.dot.png" />
        <p><small>Ejemplo de 치rbol BB.</small></p>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken" data-background="slides/trees/03.binary_search_tree/background-bst.png">
        <h2>Propiedades</h2>
    </section>

    <section>
        <h4>Recorrido inorden</h4>
        <p>El recorrido inorden por el 치rbol recorre los elementos de menor a mayor.</p>
    </section>

    <section>
        <h4>Elemento m칤nimo</h4>
        <p>El elemento m칤nimo es el primer nodo sin hijo izquierdo que encontramos si descendemos por los hijos
            izquierdos desde la ra칤z.</p>
    </section>

    <section>
        <h4>Elemento m치ximo</h4>
        <p>El elemento m치ximo es el primer nodo sin hijo derecho que encontramos si descendemos por los hijos derechos
            desde la ra칤z.</p>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken" data-background="slides/trees/03.binary_search_tree/background-bst.png">
        <h2>Operaciones</h2>
    </section>

    <section>
        <h4>B칰squeda de un elemento</h4>
        <p>Se parte de la r치iz y se desciende por el sub치rbol izquierdo si el valor buscado es menor que el del nodo o
            el sub치rbol derecho si es mayor (es una b칰squeda informada).</p>
    </section>

    <section>
        <h4>Inserci칩n de un elemento</h4>
        <p>Se realiza una b칰squeda de dicho elemento en el 치rbol y se inserta en el punto donde deber칤a encontrarse.</p>
    </section>

    <section>
        <h4>Borrado de un elemento (1/2)</h4>
        <p>Si el elemento tiene <span class="blue">cero o un hijo</span>, simplemente se borra y se adaptan los
            punteros.</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <table>
            <tr>
                <td>
                    <img src="slides/trees/03.binary_search_tree/binary_search_tree-remove0-izq.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/03.binary_search_tree/binary_search_tree-remove0-der.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Borrado de un elemento con <span class="red">cero hijos</span>.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <table>
            <tr>
                <td>
                    <img src="slides/trees/03.binary_search_tree/binary_search_tree-remove1-izq.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/03.binary_search_tree/binary_search_tree-remove1-der.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Borrado de un elemento con <span class="red">un hijo</span>.</small></p>
    </section>

    <section>
        <h4>Borrado de un elemento (2/2)</h4>
        <p>Si el elemento tiene <span class="blue">dos hijos</span>, se intercambio con el m치ximo de su sub치rbol
            izquierdo y se borra la posici칩n que ocupaba ese m치ximo.</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <table>
            <tr>
                <td>
                    <img src="slides/trees/03.binary_search_tree/binary_search_tree-remove2-izq.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/03.binary_search_tree/binary_search_tree-remove2-der.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Borrado de un elemento con <span class="red">dos hijos</span>.</small></p>
    </section>
</section>


<section data-transition="convex">
    <section data-state="darken" data-background="slides/trees/03.binary_search_tree/background-bst.png">
        <h2>Implementaci칩n</h2>
        <h4>츼rboles BB con C++</h4>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/01.binary_trees/binary_tree-structs.dot.png" />
        <p><small>Id칠ntico a un 치rbol binario.</small></p>
    </section>

    <section data-markdown>
        <script type="text/template">
### `ElementoArbolBinario.h`

Cada elemento contiene datos y punteros a los hijos izquierdo y derecho

```cpp
class ElementoArbolBinario {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementoArbolBinario> left = nullptr;
        std::shared_ptr<ElementoArbolBinario> right = nullptr;
    public:
        // Constructor 
        ElementoArbolBinario(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementoArbolBinario.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `BinarySearchTree.h`

El 치rbol es el puntero al nodo ra칤z y las operaciones que pueden realizarse con 칠l.

```cpp[3,6-7|9-11|13-18|20-23]
class BinarySearchTree {
    protected:
        std::shared_ptr<ElementoArbolBinario> root = nullptr;

    public:
        BinarySearchTree();  // Creates empty tree
        BinarySearchTree(const TipoDato& dato);  // Creates tree with root node

        // Same as BinaryTree
        int height() const;
        int size() const; // Number of nodes

        // Get data
        const TipoDato& min() const;
        const TipoDato& max() const;

        // Traverse the tree
        void dfs_inorder(std::function<void (const TipoDato&)> action) const;

        // Operations
        bool find(const TipoDato&) const;
        void push(const TipoDato&);
        void remove(const TipoDato&);
};
```
<!-- .element: class="r-stretch" -->
<small>`BinarySearchTree.h`</small>
        </script>
    </section>

    <section>
        <p>Muchas funciones son id칠nticas a las del <code>BinaryTree</code>.</p>
        <div class="footnote">Vuelve por aqu칤 cuando aprendas sobre <span class="blue">herencia de clases</span>. Ser치
            a칰n m치s sencillo que hacer copy/paste.</div>
    </section>

    <section data-markdown>
        <script type="text/template">
### `BinarySearchTree::min`

Acceso al m칤nimo

```cpp
const TipoDato& _min(std::shared_ptr<ElementoArbolBinario> element) {
    if (element->left != nullptr) {
        return _min(element->left);
    }
    else {
        return element->dato;
    }
}

const TipoDato& BinarySearchTree::min() const {
    return _min(root);
}
```
<small>`BinarySearchTree.cpp`</small>

游뚿 Si el 치rbol est치 vac칤o el comportamiento ser치 indeterminado (undefined behavior).  <!-- .element: class="footnote" -->
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `BinarySearchTree::max`

Acceso al m치ximo

```cpp
const TipoDato& _max(std::shared_ptr<ElementoArbolBinario> element) {
    if (element->right != nullptr) {
        return _max(element->right);
    }
    else {
        return element->dato;
    }
}

const TipoDato& BinarySearchTree::max() const {
    return _max(root);
}
```
<small>`BinarySearchTree.cpp`</small>

游뚿 Si el 치rbol est치 vac칤o el comportamiento ser치 indeterminado (undefined behavior).  <!-- .element: class="footnote" -->
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### BinarySearchTree::find (recursivo) <!-- .element: class="caps-preserve" -->

B칰squeda de un elemento

```cpp[20-22|1-18]
bool _find(std::shared_ptr<ElementoArbolBinario> element, 
           const TipoDato& dato) {
    // Handle corner case
    if (element == nullptr) {
        return false;
    }

    // Do actual work
    if (element->dato > dato) {
        return _find(element->left, dato);
    }
    else if (element->dato < dato) {
        return _find(element->right, dato);
    }
    else {
        return element->dato == dato;
    }
}

bool BinarySearchTree::find(const TipoDato& dato) const {
    return _find(root, dato);
}
```
<small>`BinarySearchTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### BinarySearchTree::find (iterativo) <!-- .element: class="caps-preserve" -->

Todo lo recursivo puede expresarse como iterativo

```cpp
bool BinarySearchTree::find(const TipoDato& dato) const {
    auto elem = root;
    while (elem != nullptr) {
        if (elem->dato == dato) {
            break;
        }
        else {
            elem = (dato < elem->dato) ? elem->left : elem->right;  // This is called ternary operator
        }
    }
    return elem != nullptr;
}
```
<small>`BinarySearchTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `BinarySearchTree::push`

```cpp[20-22|1-18]
void _push(std::shared_ptr<ElementoArbolBinario>& element, // Note the reference
           const TipoDato& dato) {
    // Handle corner case
    if (element == nullptr) {
        element = std::make_shared<ElementoArbolBinario>(dato);
        return;
    }

    // Do actual work
    if (element->dato > dato) {
        _push(element->left, dato);
    }
    else if (element->dato < dato) {
        _push(element->right, dato);
    }
    else {
        // It is a duplicated element! Do nothing, raise exception,...
    }
}

void BinarySearchTree::push(const TipoDato& dato) {
    return _push(root, dato);
}
```
<small>`BinarySearchTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `BinarySearchTree::remove`

Eliminar un elemento

```cpp[1-11|13-16|18-29|31-43]
void BinarySearchTree::remove(const TipoDato& dato) {
    // Find the element (keep a reference to its parent)
    auto elem = root;
    std::shared_ptr<ElementoArbolBinario> parent = nullptr;
    while (elem != nullptr) {
        if (elem->dato == dato) {
            break;
        }
        parent = elem;
        elem = (dato < elem->dato) ? elem->left : elem->right;
    }

    // If not found, nothing to do
    if (elem == nullptr) {
        return;
    }

    // If it has two childs, replace with the max element in the subtree
    if (elem->left != nullptr && elem->right != nullptr) {
        elem->dato = _max(elem->left);

        // Now the element to remove is the one at that max position
        parent = elem;
        elem = elem->left;
        while (elem->right != nullptr) {
            parent = elem;
            elem = elem->right;
        }
    }

    // Now the node to remove only has 1 or 0 childs
    auto next = (elem->left != nullptr) ? elem->left : elem->right;
    if (parent == nullptr) {
        root = next;
    }
    else {
        if (parent->left == elem) {
            parent->left = next;
        }
        else {
            parent->right = next;
        }
    }
}
```
<small>`BinarySearchTree.cpp`</small>
        </script>
    </section>

</section>

<section data-transition="convex">
    <section data-state="darken" data-background="slides/trees/03.binary_search_tree/background-bst.png">
        <h2>Utilidad</h2>
    </section>

    <section>
        <h4>Complejidad algor칤tmica (altura <code>h</code>)</h4>
        <ul>
            <li>Acceso por valor (b칰squeda): <code>O(h)</code></li>
            <li>Inserci칩n por valor: <code>O(h)</code></li>
            <li>Borrado por valor: <code>O(h)</code></li>
        </ul>
    </section>

    <section>
        <p>
            Parece una estructura de datos adecuada para implementar
            <span class="blue">diccionarios</span>, <span class="blue">mapas</span>
            o <span class="blue">listas ordenadas</span>.
        </p>
    </section>

    <section>
        <h4>Equilibrado</h4>
        <p>
            Las medidas de eficiencia son funci칩n de <code>h</code> (altura del 치rbol), pero s칩lo
            en los <span class="red">치rboles equilibrados</span> se cumple <code>h ~ log(n)</code>
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Que un 치rbol BB est칠 equilibrado o no depende de la secuencia de inserciones. El
            peor caso es la inserci칩n de los elementos en orden. Todas las operaciones se
            convierten en <code>O(n)</code>.
        </p>
        <img class="r-stretch" src="slides/trees/03.binary_search_tree/binary_search_tree-insert-order.dot.png" />
        <p><small>Se conoce como 치rbol BB degenerado (es una lista).</small></p>
    </section>
</section>

<section data-transition="convex">
    <section data-background="images/background-actividades.png">
        <h2>Ejercicios propuestos</h2>
    </section>

    <section>
        <h4>游똂 Tu propia biblioteca de TADs: binary_search_trye</h4>
        <p>Reune el c칩digo relacionado con los 치rboles BB en tu ordenador, junto al de otros TAD</p>
    </section>

    <section>
        <p>Necesitar치s a침adir:</p>
        <ul>
            <li><code>BinarySearchTree.h</code></li>
            <li><code>BinarySearchTree.cpp</code></li>
        </ul>
    </section>

    <section>
        <p>Haz ejemplos con esta clase, aseg칰rate de que sus m칠todos funcionan para todos los escenarios posibles.</p>
    </section>

    <section>
        <p>Prueba a implementar los m칠todos de manera recursiva y tambi칠n de manera iterativa.</p>
    </section>

    <section>
        <p>Implementa una clase para un 치rbol BB que admita nodos con <span class="blue">valores duplicados</span>.</p>
    </section>
</section>