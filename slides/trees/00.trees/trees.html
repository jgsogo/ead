<section data-transition="convex">
    <section>
        <h2>Definiciones y propiedades</h2>
    </section>

    <section>
        <h4>Árbol</h4>
        <p>
            Un <span class="blue">árbol</span> es un TAD que consta de un nodo (<span class="red">nodo raíz</span>) y
            una lista o conjunto de subárboles.
        </p>
    </section>

    <section>
        <h4>Árbol ordenado (árbol)</h4>
        <p>
            Cuando el orden de los subárboles es importante (lista), se dice que es un <span class="blue">árbol
                ordenado</span> (*).
        </p>
        <p class="footnote">(*) Por defecto un árbol se considera ordenado.</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Ejemplo de árbol [ordenado]</p>
        <img class="stretch" src="slides/trees/00.trees/tree.dot.png" />
        <p><small>Se dice que es ordenado porque los subárboles con nodo raíz <code>b</code>, <code>c</code> y
                <code>d</code> son una lista.</small></p>
    </section>

    <section>
        <h4>Tipos de nodos</h4>
        <ul>
            <li><strong class="blue">Nodo raíz</strong>: <em>cabeza</em> o primer elemento del árbol.</li>
            <li><strong class="blue">Nodo hijo</strong>: son los nodos raíz de los subárboles.</li>
            <li><strong class="blue">Nodo padre</strong>: si <code>b</code> es un nodo hijo de <code>a</code>, entonces
                <code>a</code> es el nodo padre de <code>b</code>.</li>
            <li><strong class="blue">Nodo hoja o externo</strong>: nodo que no tiene hijos.</li>
            <li><strong class="blue">Nodo interno</strong>: cualquier nodo con algún hijo.</li>
        </ul>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <div class="left">
            <img src="slides/trees/00.trees/tree-node-types.dot.png" />
        </div>
        <div class="right">
            <p>Tipos de nodos</p>
            <ul>
                <li class="red">Nodo raíz</li>
                <li class="blue">Nodo hoja o externo</li>
                <li>Nodo interno</li>
            </ul>
        </div>
    </section>

    <section>
        <h4>Camino</h4>
        <p>
            Cualquier secuencia de nodos <code>n<sub>1</sub>...n<sub>p</sub></code> que cumpla que cada nodo es el padre
            del siguiente en la secuencia.
        </p>
        <p class="fragment">La <span class="blue">longitud de un camino</span> es el número de nodos menos uno
            (<code>p-1</code>)</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Descendientes</h4>
        <div class="left">
            <p>Todos los nodos accesibles por un camino que comience en dicho nodo.</p>
            <hr />
            <p>Los descendientes del nodo <code class="blue">c</code> son <code class="red">{e, f, g}</code></p>
        </div>
        <div class="right">
            <img src="slides/trees/00.trees/tree-descendents.dot.png" />
        </div>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Ascendientes</h4>
        <div class="left">
            <p>Nodos del camino que va desde el nodo raíz hasta el nodo en consideración.</p>
            <hr />
            <p>Los asciendentes del nodo <code class="blue">g</code> son <code class="red">{a, c, f}</code></p>
        </div>
        <div class="right">
            <img src="slides/trees/00.trees/tree-ascendents.dot.png" />
        </div>
    </section>

    <section>
        <h4>Altura</h4>
        <p>
            La <span class="blue">altura de un nodo</span> es la logitud del camino más largo que
            comienza en el nodo y termina en una hoja.</p>
        <p class="fragment">
            La <span class="blue">altura de un árbol</span> es la altura de su nodo raíz.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/00.trees/tree-altura.dot.png" />
        <p>La altura de un nodo se puede calcular como la mayor de las alturas de sus nodos hijo más una unidad.</p>
    </section>

    <section>
        <h4>Profundidad</h4>
        <p>
            La <span class="blue">profundidad de un nodo</span> es la logitud del camino (único) que comienza en la raíz
            y termina en el nodo.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/00.trees/tree-depth.dot.png" />
        <p>La profundidad de un nodo es la profundidad de su nodo padre más uno.</p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Recorrido de árboles</h2>
    </section>

    <section>
        <h4>Búsqueda no informada</h4>
        <p>
            Se recorre todo el árbol sin tener una pista de donde se encuentra el elemento buscado. También se conoce
            como <span class="blue">búsqueda a ciegas</span>.
        </p>
    </section>

    <section>
        <p>Estrategias de búsqueda no informada:</p>
        <ul>
            <li>Recorrido en profundidad</li>
            <li>Recorrido en anchura</li>
        </ul>
    </section>

    <section>
        <h4>Búsqueda informada</h4>
        <p>
            Cuando existe un criterio de ordenación para los elementos del árbol (*) se puede optimizar el
            recorrido del árbol.
        </p>
        <hr />
        <p>
            Los <a href="13.binary_search_trees.html">árboles binarios de búsqueda</a> son ejemplos de árboles que
            presentan esta propiedad.
        </p>
        <div class="footnote">(*) No confundir con árbol ordenado, que se refiere al orden de los subárboles.</div>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Recorrido en profundidad</h2>
        <h4>Depth-first search (DFS)</h4>
    </section>

    <section>
        <p>En un <span class="blue">recorrido en profundidad</span> se recorre cada uno de los subárboles de un nodo
            antes de pasar al siguiente subárbol del mismo nodo (*).</p>
        <div class="footnote">(*) Nótese que es una definición recursiva.</div>
    </section>

    <section>
        <h4>Recorrido pre-orden</h4>
        <p>Se vista el nodo raíz y luego se recorre en pre-orden cada uno de los subárboles (recursivo).</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>DFS pre-orden</p>
        <img class="r-stretch" src="slides/trees/00.trees/tree-dfs-preorden.dot.png" />
        <p><code>a, b, c, e, f, g, d</code></p>
    </section>

    <section>
        <h4>Recorrido post-orden</h4>
        <p>Se recorre en post-orden cada uno de los subárboles y luego se visita el nodo raíz (recursivo).</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>DFS post-orden</p>
        <img class="r-stretch" src="slides/trees/00.trees/tree-dfs-preorden.dot.png" />
        <p><code>b, e, g, f, c, d, a<code></p>
    </section>

    <section>
        <h4>Recorrido in-orden (*)</h4>
        <p>Se recorre en in-orden el primer subárbol (si existe), luego se visita el nodo raíz y después se recorre en
            in-orden los subárboles restantes (recursivo).</p>
        <div class="footnote">Tiene sentido fundamentalmente en <a href="11.binary_trees.html">árboes binarios</a></div>.
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>DFS in-orden</p>
        <img class="r-stretch" src="slides/trees/00.trees/tree-dfs-preorden.dot.png"/>
        <p><code>b, e, g, f, c, d, a<code></p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Recorrido en anchura/amplitud</h2>
        <h4>Breadth-first search (BFS)</h4>
    </section>

    <section>
        <p>
            En un <span class="blue">recorrido en anchura</span> se recorren todos los nodos de un mismo nivel antes de
            pasar al siguiente nivel.
        </p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Implementación</h2>
    </section>
</section>