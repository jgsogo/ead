
<section data-transition="convex">
    <section data-background="slides/eda2.0/images/backtothefutureIII.jpg">
        <h4 class="fragment box-shadow-black">EDA 3.0</h4>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Plantillas</h2>
        <h4><span class="caps-preserve">aka</span> Templates</h4>
    </section>

    <section>
        Las plantillas son una caracter√≠stica del lenguaje C++ que podemos utilizar
        para generalizar nuestro c√≥digo, para que las funciones y las clases trabajen
        con tipos gen√©ricos.
    </section>

    <section data-markdown>
        <script type="text/template">
¬°Ya las has estado utilizando!

```cpp[5-6,9-10]
#include <vector>

int main() {
    // A vector of integers
    std::vector<int> numbers;
    numbers.push_back(23);

    // A vector of strings
    std::vector<std::string> words;
    words.push_back("palabra");
}
```
        </script>
    </section>

    <section>
        <h4>Ejemplo</h4>
        <p>Imprimir los valores contenidos en un <code class="grey">std::vector</code></p>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[4-8|17-21]
#include <vector>
#include <iostream>

void print(const std::vector<int>& values) {
    for (auto v: values) {
        std::cout << v << std::endl;
    }
}

int main() {
    std::vector<int> numbers;
    numbers.push_back(1);
    numbers.push_back(2);
    numbers.push_back(3);
    print(numbers);

    std::vector<std::string> words;
    words.push_back("las");
    words.push_back("plantillas");
    words.push_back("son");
    print(words); // üëéüëé Compile error
}
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp[4-8|17-21]
#include <vector>
#include <iostream>

void print(const std::vector<std::string>& values) {
    for (auto v: values) {
        std::cout << v << std::endl;
    }
}

int main() {
    std::vector<std::string> words;
    words.push_back("las");
    words.push_back("plantillas");
    words.push_back("son");
    print(words);

    std::vector<float> values;
    values.push_back(1.23);
    values.push_back(2.32);
    values.push_back(5.45);
    print(values); // üëéüëé Compile error
}
```
        </script>
    </section>

    <section data-background="slides/eda2.0/images/stressed.jpg">
        <p class="box-shadow-white black">¬°Necesito una funci√≥n para cada tipo de dato!</p>
        <div class="credit white">Imagen: <a href="https://mediafocus.biz/5-stress-reducing-computer-tips/">Mediafocus</a></div>
    </section>

    <section data-state="darken" data-markdown data-background="slides/eda2.0/images/stressed.jpg">
        <script type="text/template">
Las plantillas nos permiten evitar el tener que escribir el mismo c√≥digo una y otra vez

```cpp[4-8|12-16,18-22]
#include <vector>
#include <iostream>

template <typename T>
void print(const std::vector<T>& values) {
    for (auto v: values) {
        std::cout << v << std::endl;
    }
}

int main() {
    std::vector<std::string> words;
    words.push_back("las");
    words.push_back("plantillas");
    words.push_back("son");
    print(words);

    std::vector<float> values;
    values.push_back(1.23);
    values.push_back(2.32);
    values.push_back(5.45);
    print(values);
}
```
        </script>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Funciones con plantillas</h2>
    </section>

    <section>
        <p>Podemos <em>generalizar</em> una funci√≥n utilizando plantillas</p>
    </section>

    <section>
        <h4>Algoritmos de ordenaci√≥n</h4>
    </section>

    <section data-markdown data-transition="none-out">
        <script type="text/template">
M√©todo de la burbuja (`std::vector<int>`)

```cpp[]
void bubble_sort(std::vector<int>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
```
        </script>
    </section>

    <section data-markdown data-transition="none-in none-out">
        <script type="text/template">
M√©todo de la burbuja (`std::vector<float>`)

```cpp[]
void bubble_sort(std::vector<float>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
```
        </script>
    </section>

    <section data-markdown data-transition="none-in none-out">
        <script type="text/template">
M√©todo de la burbuja (`std::vector<string>`)

```cpp[]
void bubble_sort(std::vector<std::string>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
```
        </script>
    </section>

    <section data-markdown data-transition="none-in none-out">
        <script type="text/template">
![alt text](slides/eda2.0/images/waitforit.gif) <!-- .element: class="r-stretch" -->

```cpp[]
///hide
#include <vector>
#include <iostream>

template <typename T>
void print(const std::vector<T>& values) {
    for (auto v: values) {
        std::cout << v << std::endl;
    }
}

///unhide
template <typename T>
void bubble_sort(std::vector<T>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
///hide

int main() {
    std::vector<std::string> words;
    words.push_back("las");
    words.push_back("plantillas");
    words.push_back("son");
    bubble_sort(words);
    print(words);

    std::vector<float> values;
    values.push_back(8.23);
    values.push_back(2.32);
    values.push_back(5.45);
    bubble_sort(values);
    print(values);
}
///unhide
```
<!-- .element: class="fragment" -->
        </script>
    </section>

    <section>
        <h4>Plantillas + sobrecarga de operadores</h4>
    </section>

    <section data-markdown data-transition="none-in none-out">
        <script type="text/template">
¬øY funci√≥nar√° con mis tipos de datos?

```cpp[|12]
#include <iostream>

class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        bool operator<(const ComplexNumber& other) const;
        friend std::ostream& operator<<(std::ostream& os, const ComplexNumber& number);
};

std::ostream& operator<<(std::ostream& os, const ComplexNumber& number) {
    os << number.real << " + " << number.im << "i";
    return os;
}
```
<small>`ComplexNumber.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
M√©todo de la burbuja (final version)

```cpp[]
template <typename T>
void bubble_sort(std::vector<T>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
```
<small>`bubble_sort.h`</small>
        </script>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Clases con plantillas</h2>
    </section>

    <section>
        Tambi√©n se puede <em>generalizar</em> una clase utilizando plantillas
    </section>

    <section>
        <h4>Ej. Mont√≠culos / Colas de prioridad</h4>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p class="caps"><strong>Mont√≠culo (de m√≠nimos)</strong></p>
        <p>√Årbol binario completo en el que todo nodo es menor que sus descendientes</p>
        <img class="r-stretch" src="slides/trees/02.heaps/heap-example.dot.png" />
    </section>

    <section data-markdown>
        <script type="text/template">
Pod√≠amos almacenarlo en un 
`std::vector` <!-- .element: class="grey" -->

```cpp

class PriorityQueue {
    public:
        PriorityQueue();

        int size() const;
        bool empty() const;

        const TipoDato& top() const;
        void push(const TipoDato& dato);
        void pop();

    protected:
        std::vector<TipoDato> _data;
};
```
<small>`PriorityQueue.h`</small>
        </script>
    </section>

    <section>
        Para implementar colas de prioridad de diferentes tipos de datos (aviones, empleados,...)
        lo que hac√≠amos era implementar la clase <code class="grey">TipoDato</code> para
        representar la abstracci√≥n correspondiente.
    </section>

    <section data-markdown>
        <script type="text/template">
Mont√≠culo (final version) 

```cpp
template <typename TipoDato>
class PriorityQueue {
    public:
        PriorityQueue();

        int size() const;
        bool empty() const;

        const TipoDato& top() const;
        void push(const TipoDato& dato);
        void pop();

    protected:
        std::vector<TipoDato> _data;
};
```
<small>`PriorityQueue.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Al igual que hacemos con un
`std::vector` <!-- .element: class="grey" -->
podemos hacer ahora con nuestro
`PriorityQueue` <!-- .element: class="grey" -->

```cpp[|4]
#include "PriorityQueue.h"

int main() {
    PriorityQueue<int> q1;
    q1.push(8);
    q1.push(5);
    q1.push(3);
    
    while (!q1.empty()) {
        auto dato = q1.top();
        q1.pop();
        std::cout << dato << std::endl;
    }
}
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
¬°Y funciona con nuestros tipos de datos! ([Actividad 14](12.heaps.html#/6))

```cpp[|5]
class Avion {
    public:
        Avion(int hora_salida, int minuto_salida, bool is_transplante, bool is_jet);

        bool operator<(const Avion& other) const;
    private:
        /* ... atributtes not showing here... */
};
```

```cpp[|2]
int main() {
    PriorityQueue<Avion> pista_despegue;
    pista_despegue.push(Avion{10, 15, false, false});
    pista_despegue.push(Avion{13, 30, true, false});
    // ...
};
```

<div class="footnote">Siempre que sobrecarguen los operadores que necesita el <code class="grey">PriorityQueue</code></div>
        </script>
    </section>

    <section>
        <h4>Plantillas + clases</h4>
        <ul>
            <li>üíô  El algoritmo y el dato ahora S√ç son totalmente independientes</li>
            <li>ü§∑‚Äç‚ôÄÔ∏è  La implementaci√≥n de la clase no puede separarse en <code class="grey">.h</code> y <code class="grey">.cpp</code></li>
        </ul>
    </section>
</section>


<section data-transition="convex">
    <section data-background="images/list-shopping-list.jpeg">
        <h4 class="box-shadow-black">Ej. Listas</h4>
    </section>

    <section>
        En üôè <em>Tu propia biblioteca de TADs</em> deber√≠ais tener algunos ficheros como 
        <code class="grey">LinkedList.h</code> o <code class="grey">ElementListaSimple.h</code>
        con el c√≥digo correspondiente a las listas.
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp
class ElementListaSimple {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementListaSimple> next = nullptr;
    public:
        // Constructor 
        ElementListaSimple(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementListaSimple.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp
class LinkedList {
    public:
        LinkedList();
        
        int size() const;
        void for_each(std::function<void (TipoDato&)> action) const;
        void push_back(const TipoDato& dato);

        /* ... more methods ... */
    protected:
        std::shared_ptr<ElementListaSimple> _front = nullptr;
};
```
<small>`LinkedList.h`</small>
        </script>
    </section>

    <section>
        Podemos generalizar <code class="grey">LinkedList</code> (y tambi√©n <code class="grey">ElementListaSimple</code>)
        utilizando plantillas.
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp
template <typename TipoDato>
class ElementListaSimple {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementListaSimple<TipoDato>> next = nullptr;
    public:
        // Constructor 
        ElementListaSimple(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementListaSimple.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Lista simple enlazada (final version)

```cpp
template <typename TipoDato>
class LinkedList {
    public:
        LinkedList();
        
        int size() const;
        void for_each(std::function<void (TipoDato&)> action) const;
        void push_back(const TipoDato& dato);

        /* ... more methods ... */
    protected:
        std::shared_ptr<ElementListaSimple<TipoDato>> _front = nullptr;
};
```
<small>`LinkedList.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Hemos desacoplados los datos de los algoritmos:

```cpp
#include "LinkedList.h"

struct Empleado {
    int id;
    bool is_boss
};

int main() {
    LinkedList<Empleado> employees;
    
    Empleado e1{123, false};
    Empleado e2{999, true};
    employees.push_back(e1);
    employees.push_back(e2);
}
```
        </script>
    </section>
</section>


<section data-transition="convex">
    <section data-background="slides/trees/03.binary_search_tree/background-bst.png">
        <h4 class="box-shadow-black">Ej. √Årbol binario de b√∫squeda</h4>
    </section>

    <section>
        En üôè <em>Tu propia biblioteca de TADs</em> deber√≠ais tener algunos ficheros como 
        <code class="grey">BinarySearchTree.h</code> o <code class="grey">ElementoArbolBinario.h</code>
        con el c√≥digo correspondiente a las √°rboles binarios de b√∫squeda.
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/01.binary_trees/binary_tree-structs.dot.png" />
        <p><small>Estructura de un √°rbol binario.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/03.binary_search_tree/binary_search_tree_example-schema.dot.png" />
        <p><small>Todos los nodos del sub√°rbol izquierdo son menores que <code>x</code>, los del sub√°rbol derecho
                mayores que <code>x</code>.</small></p>
    </section>

    <section>
        Podemos <em>generalizar</em> esta estructura de datos utilizando plantillas.
    </section>

    <section data-menu-title="ElementoArbolBinario.h" data-markdown data-transition="none-out">
        <script type="text/template">
`ElementoArbolBinario.h`

```cpp

class ElementoArbolBinario {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementoArbolBinario> left = nullptr;
        std::shared_ptr<ElementoArbolBinario> right = nullptr;
    public:
        // Constructor 
        ElementoArbolBinario(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementoArbolBinario.h`</small>
        </script>
    </section>

    <section data-markdown data-transition="none-in">
        <script type="text/template">
`ElementoArbolBinario.h` (final version)

```cpp
template <typename TipoDato>
class ElementoArbolBinario {
    public:
        // Members
        TipoDato dato;
        std::shared_ptr<ElementoArbolBinario<TipoDato>> left = nullptr;
        std::shared_ptr<ElementoArbolBinario<TipoDato>> right = nullptr;
    public:
        // Constructor 
        ElementoArbolBinario(const TipoDato& dato_) : dato{dato_} {};
};
```
<small>`ElementoArbolBinario.h`</small>
        </script>
    </section>

    <section data-menu-title="BinarySearchTree.h" data-markdown data-transition="none-out">
        <script type="text/template">
`BinarySearchTree.h`

```cpp[]

class BinarySearchTree {
    protected:
        std::shared_ptr<ElementoArbolBinario> root = nullptr;

    public:
        BinarySearchTree();  // Creates empty tree

        // Same as BinaryTree
        int height() const;
        int size() const; // Number of nodes

        // Get data
        const TipoDato& min() const;
        const TipoDato& max() const;

        // Traverse the tree
        void dfs_inorder(std::function<void (const TipoDato&)> action) const;

        // Operations
        bool find(const TipoDato&) const;
        void push(const TipoDato&);
        void remove(const TipoDato&);
};
```
<small>`BinarySearchTree.h`</small>
        </script>
    </section>

    <section data-markdown data-transition="none-in">
        <script type="text/template">
`BinarySearchTree.h` (final version)

```cpp[]
template <typename TipoDato>
class BinarySearchTree {
    protected:
        std::shared_ptr<ElementoArbolBinario<TipoDato>> root = nullptr;

    public:
        BinarySearchTree();  // Creates empty tree

        // Same as BinaryTree
        int height() const;
        int size() const; // Number of nodes

        // Get data
        const TipoDato& min() const;
        const TipoDato& max() const;

        // Traverse the tree
        void dfs_inorder(std::function<void (const TipoDato&)> action) const;

        // Operations
        bool find(const TipoDato&) const;
        void push(const TipoDato&);
        void remove(const TipoDato&);
};
```
<small>`BinarySearchTree.h`</small>
        </script>
    </section>
</section>


<section data-transition="convex">
    <section data-background="slides/eda2.0/images/alice-rabbit-hole.jpg">
        <h2>Down the rabbit hole</h2>
        <h4>Algunas curiosidades</h4>
        <div class="credit">Alice in wonderland (Tim Burton, 2010)</div>
    </section>

    <section>
        <p>El compilador eval√∫a/traduce las plantillas en tiempo de compilaci√≥n (antes de ejecutar el programa)</p>
    </section>

    <section data-menu-title="Operaciones" data-markdown data-transition="none-in">
        <script type="text/template">
Se pueden hacer operaciones utilizando plantillas

```cpp[]
#include <iostream>

template <int N>
struct AddOne {
    enum { val = N + 1 };
};

int main()
{
    std::cout << AddOne<5>::val << "\n";
}
```
        </script>
    </section>

    <section data-markdown data-transition="none-in">
        <script type="text/template">
Se pueden hacer operaciones utilizando plantillas

```cpp[]
#include <iostream>

template <int N1, int N2>
struct Product {
    enum { val = N1 * N2 };
};

int main()
{
    std::cout << Product<5, 3>::val << "\n";
}
```
        </script>
    </section>

    <section data-menu-title="Recursividad" data-markdown data-transition="none-in">
        <script type="text/template">
Se pueden hacer recursividad con plantillas

```cpp[]
#include <iostream>

template <int N> struct Factorial {
    enum { val = Factorial<N-1>::val * N };
};

template<>
struct Factorial<0> {
    enum { val = 1 };
};

int main() {
    std::cout << Factorial<4>::val << "\n";
}
```

<small>¬°El resultado se calcula en tiempo de compilaci√≥n!</small>
        </script>
    </section>

    <section>
        <p>C++ templates are turing complete (Veldhuizen, 2003)</p>
        <p><a href="https://rtraba.files.wordpress.com/2015/05/cppturing.pdf"></a></p>
        <div class="footnote">Wikipedia: <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing completeness</a></div>
    </section>

    <section>
        <p>Se pueden resolver problemas en tiempo de compilaci√≥n: Juego de la vida de Conway (<a href="https://github.com/engelmarkus/conway">link</a>)</p>
        <hr/>
        <p>El programa compilado (el ejecutable) s√≥lo contiene una cadena de texto (el resultado) ü§Ø</p>
    </section>

    <section data-state="darken" data-background="slides/eda2.0/images/template-error.png">
        <p>Templates are hard</p>
    </section>

    <section data-background="slides/eda2.0/images/template-error.png">
        <p class="box-shadow-black white">Template errors are much harder</p>
    </section>

    <section>
        <p>C++ template metaprogramming</p>
        <img class="r-stretch" src="slides/eda2.0/images/gandalf.jpg" />
    </section>
</section>
