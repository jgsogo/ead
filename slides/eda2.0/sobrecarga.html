<section data-transition="convex">
    <section>
        <h2>Introducción</h2>
    </section>

    <section>
        <p>
            Se trata de un mecanismo que permite aumentar las capacidades de un lenguaje de
            programación con orientación a objetos.
        </p>
    </section>

    <section data-markdown>
        <script type="text/template">
#### Tipos nativos del lenguaje

El lenguaje sabe operar con algunos <span class="blue">tipos nativos</span> como
<code>int</code>, <code>float</code>,...

```cpp
#include <iostream>

int main() {
    int a = 20;
    int b = 30;
    int c = a + b;
    std::cout << "a + b = " << c << std::endl;
}
```

Sabe realizar las operaciones básicas
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
#### Programación orientada a objetos

La <span class="blue">programación orientada a objetos</span> nos permite definir nuestros propios tipos de datos:

```cpp
#include <iostream>

struct ComplexNumber {
    float real;
    float im;
};

int main() {
    ComplexNumber a{10, 10};
    ComplexNumber b{30, 30};
    ComplexNumber c = a + b;
    std::cout << "a + b = " << c << std::endl;
}
```

Pero no sabe operar con ellos
        </script>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Usando funciones libres</h2>
    </section>

    <section>
        <h4>Operadores aritméticos</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Cuando los datos miembro son públicos, se pueden utilizar funciones libres:

```cpp[8-13]
#include <iostream>

struct ComplexNumber {
    float real;
    float im;
};

ComplexNumber operator+(const ComplexNumber& lhs, const ComplexNumber& rhs) {
    ComplexNumber result;
    result.real = lhs.real + rhs.real;
    result.im = lhs.im + rhs.im;
    return result;
}

int main() {
    ComplexNumber a{10, 10};
    ComplexNumber b{30, 30};
    ComplexNumber c = a + b;
    std::cout << "a + b = " << std::endl;
    std::cout << "\tc.real = " << c.real << std::endl;
    std::cout << "\tc.im = " << c.im << std::endl;
}
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Se pueden sobrecargar _todos_ los operadores:

```cpp[29-37|8-13|15-20|22-27]
#include <iostream>

struct ComplexNumber {
    float real;
    float im;
};

ComplexNumber operator+(const ComplexNumber& lhs, const ComplexNumber& rhs) {
    ComplexNumber result;
    result.real = lhs.real + rhs.real;
    result.im = lhs.im + rhs.im;
    return result;
}

ComplexNumber operator-(const ComplexNumber& lhs, const ComplexNumber& rhs) {
    ComplexNumber result;
    result.real = lhs.real - rhs.real;
    result.im = lhs.im - rhs.im;
    return result;
}

ComplexNumber operator*(const ComplexNumber& lhs, const ComplexNumber& rhs) {
    ComplexNumber result;
    result.real = (lhs.real * rhs.real) - (lhs.im * rhs.im);
    result.im = (lhs.real * rhs.im) + (lhs.im * rhs.real);
    return result;
}

int main() {
    ComplexNumber a{10, 10};
    ComplexNumber b{30, 30};
    ComplexNumber c = a + b;
    ComplexNumber d = a - b;
    ComplexNumber e = a * b;
    // And more complicated expressions
    (c + d) * (e - c);
}
```
        </script>
    </section>

    <section>
        <h4>Operadores unarios</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
También se pueden sobrecargar operadores unarios:

```cpp[15-20|8-13]
#include <iostream>

struct ComplexNumber {
    float real;
    float im;
};

ComplexNumber operator-(const ComplexNumber& lhs) {
    ComplexNumber result;
    result.real = -lhs.real;
    result.im = -lhs.im;
    return result;
}

int main() {
    ComplexNumber a{10, 10};
    ComplexNumber b = -a;
    std::cout << "b.real: "<< b.real << std::endl;
    std::cout << "b.im: "<< b.im << std::endl;
}
```
        </script>
    </section>

    <section>
        <h4>Operadores con otros tipos de datos</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Operaciones con otros tipos de datos:

```cpp[15-20|8-13]
#include <iostream>

struct ComplexNumber {
    float real;
    float im;
};

ComplexNumber operator*(float lhs, const ComplexNumber& rhs) {
    ComplexNumber result;
    result.real = lhs * rhs.real;
    result.im = lhs * rhs.im;
    return result;
}

int main() {
    ComplexNumber a{10, 10};
    ComplexNumber b = 20 * a;
    std::cout << "b.real: "<< b.real << std::endl;
    std::cout << "b.im: "<< b.im << std::endl;
}
```

¡El **orden de los operandos** importa! 
        </script>
    </section>

</section>


<section data-transition="convex">
    <section>
        <h2>Sobrecarga y encapsulamiento</h2>
    </section>

    <section>
        El encapsulamiento es <em>lo mejor</em> de la programación orientada a objetos, nos
        permite esconder datos y comportamiento, y forzar a nuestros usuarios a utilizar la
        interfaz que les ofrecemos.
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp
#include <iostream>

class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        float get_real() const { return real; }
        float get_im() const { return im; }
};
///hide
ComplexNumber operator+(const ComplexNumber& lhs, const ComplexNumber& rhs) {
    ComplexNumber result;
    result.real = lhs.real + rhs.real;
    result.im = lhs.im + rhs.im;
    return result;
}

int main() {
    ComplexNumber a{10, 10};
    ComplexNumber b{30, 30};
    ComplexNumber c = a + b;
    std::cout << "a + b = " << std::endl;
    std::cout << "\tc.real = " << c.get_real() << std::endl;
    std::cout << "\tc.im = " << c.get_im() << std::endl;
}
///unhide
```
        </script>
    </section>

    <section>
        Las funciones libres ya no pueden acceder a los miembros de la clase 😱 
    </section>

    <section>
        <h4>Operadores amigos (<code>friend</code>)</h4>
    </section>

    <section>
        Una clase puede declarar que otras funciones son <span class="blue"><em>amigas</em></span>
        y esas funciones podrán acceder a sus datos privados.
    </section>

    <section data-markdown>
        <script type="text/template">
Las funciones `friend` se añaden a la declaración de la clase:

```cpp[18-23|15]
#include <iostream>

class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        float get_real() const { return real; }
        float get_im() const { return im; }

        friend ComplexNumber operator+(const ComplexNumber& lhs, const ComplexNumber& rhs);
};

ComplexNumber operator+(const ComplexNumber& lhs, const ComplexNumber& rhs) {
    ComplexNumber result;
    result.real = lhs.real + rhs.real;
    result.im = lhs.im + rhs.im;
    return result;
}
///hide
int main() {
    ComplexNumber a{10, 10};
    ComplexNumber b{30, 30};
    ComplexNumber c = a + b;
    std::cout << "a + b = " << std::endl;
    std::cout << "\tc.real = " << c.get_real() << std::endl;
    std::cout << "\tc.im = " << c.get_im() << std::endl;
}
///unhide
```
        </script>
    </section>

    <section data-menu-title="" data-background="slides/eda2.0/images/barney-highfive.gif">
        <h4 class="box-shadow-white">Encapsulamiento + sobrecarga</h4>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Sobrecarga y encapsulamiento (con funciones miembro)</h2>
    </section>

    <section>
        <h4><code>friend</code> functions are evil!</h4>
        <img src="slides/eda2.0/images/friend-zone-icon.png" class="">
        <p>Evita usar <code>friend</code> siempre que sea posible</p>
    </section>

    <section>
        <h4>Operadores aritméticos</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Sobrecarga de operadores con funciones miembro:

```cpp[|15-17]
#include <iostream>

class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        float get_real() const { return real; }
        float get_im() const { return im; }

        ComplexNumber operator+(const ComplexNumber& other) const;
        ComplexNumber operator-(const ComplexNumber& other) const;
        ComplexNumber operator*(const ComplexNumber& other) const;
};
```
<small>`ComplexNumber.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Las funciones miembro tienen acceso a los miembros de la clase:

```cpp
#include "ComplexNumber.h"

ComplexNumber ComplexNumber::operator+(const ComplexNumber& other) const {
    ComplexNumber result;
    result.real = this->real + other.real;
    result.im = this->im + other.im;
    return result;
}

ComplexNumber ComplexNumber::operator-(const ComplexNumber& other) const {
    ComplexNumber result;
    result.real = this->real - other.real;
    result.im = this->im - other.im;
    return result;
}

ComplexNumber ComplexNumber::operator*(const ComplexNumber& other) const {
    // ...
}

```
<small>`ComplexNumber.cpp`</small>
        </script>
    </section>

    <section>
        <h4>Operadores unarios</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Operadores con un único operando:

```cpp[|13]
///hide
#include <iostream>

///unhide
class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        float get_real() const { return real; }
        float get_im() const { return im; }

        ComplexNumber operator-() const;
};
///hide

ComplexNumber ComplexNumber::operator-() const {
    ComplexNumber result;
    result.real = -this->real;
    result.im = -this->im;
    return result;
}

int main() {
    ComplexNumber a{10, 20};
    ComplexNumber b = -a;
    std::cout << b.get_real() << " + " << b.get_im() << "i" << std::endl;
}
///unhide
```
<small>`ComplexNumber.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Las funciones miembro tienen acceso a los miembros de la clase:

```cpp
#include "ComplexNumber.h"

ComplexNumber ComplexNumber::operator-() const {
    ComplexNumber result;
    result.real = -this->real;
    result.im = -this->im;
    return result;
}
```
<small>`ComplexNumber.cpp`</small>
        </script>
    </section>

    <section>
        <h4>Operadores con otros tipos de datos</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
Operadores con otros tipos de datos:

```cpp[13]
///hide
#include <iostream>

///unhide
class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        float get_real() const { return real; }
        float get_im() const { return im; }

        ComplexNumber operator*(float coeficient) const;
};
///hide

ComplexNumber ComplexNumber::operator*(float coeficient) const {
    ComplexNumber result;
    result.real = coeficient * this->real;
    result.im = coeficient * this->im;
    return result;
}

int main() {
    ComplexNumber a{10, 20};
    ComplexNumber b = a * 20;
    std::cout << b.get_real() << " + " << b.get_im() << "i" << std::endl;
}
///unhide
```
<small>`ComplexNumber.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Las funciones miembro tienen acceso a los miembros de la clase:

```cpp[|15-17]
#include "ComplexNumber.h"

ComplexNumber ComplexNumber::operator*(float coeficient) const {
    ComplexNumber result;
    result.real = this->real * coeficient;
    result.im = this->im * coeficient;
    return result;
}
```
<small>`ComplexNumber.cpp`</small>
        </script>
    </section>

    <section>
        ¡Mucho cuidado cuando las operaciones no son conmutativas! Habrá que sobrecargar el operador en la clase correspondiente al primer operando.
        <hr/>
        ¿Y si el primer operando es un tipo básico de datos? <span class="fragment">Nos queda la opción de la función libre y la declaración <code>friend</code>.</span>
    </section>

    <section data-menu-title="" data-background="slides/eda2.0/images/barney-robin.gif">
        <h4 class="box-shadow-white">Sobrecarga y funciones miembro</h4>
    </section>
</section>



<section data-transition="convex">
    <section>
        <h2>Operador <code>&#60;&#60;</code></h2>
    </section>

    <section>
        El <span class="blue">operador <code>&#60;&#60;</code></span> se utiliza para enviar datos a un stream, típicamente a un
        <code>std::ostream</code> y la mayoría de las veces a <code>std::cout</code>.
    </section>

    <section data-markdown>
        <script type="text/template">
Es un operador binario entre dos tipos de datos diferentes: el *stream* y el dato que se quiere mostrar:

```cpp
///hide
#include <iostream>

int main() {
///unhide
std::cout << "palabra"; // operator<<(ostream, std::string)
///hide
}
///unhide
```

<hr/>

```cpp
2 + 3; // operator+(int, int)
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Su valor de retorno es un *stream*, y por eso **se puede concatenar**:

```cpp
///hide
#include <iostream>

int main() {
///unhide
(std::cout << "palabra") << "otra"; // ostream operator<<(ostream, std::string)
///hide
}
///unhide
```

<hr/>

```cpp
(2 + 3) + 8; // int operator+(int, int)
```
        </script>
    </section>

    <section>
        No es un operador conmutativo, el <code>std::ostream</code> es el operando izquierdo.
        <span class="fragment">
            <hr/>
            Habría que añadir el operador sobrecargado a la clase <code>std::ostream</code>, pero no podemos.
        </span>
        <span class="fragment">
            <hr/>
            La solución es utilizar una función libre.
        </span>
    </section>

    <section data-markdown>
        <script type="text/template">
Operador `<<`

```cpp[16-19]
#include <iostream>

class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        float get_real() const { return real; }
        float get_im() const { return im; }
};

std::ostream& operator<<(std::ostream& os, const ComplexNumber& number) {
    os << number.get_real() << " + " << number.get_im() << "i";
    return os;
}

int main() {
    ComplexNumber a{10, 20};
    std::cout << a << std::endl;
}
```
<small>`ComplexNumber.h`</small>
        </script>
    </section>

    <section>
        🤔  ¿Realmente quiero exponer en mi clase <code>ComplexNumber</code> los métodos <code>get_real</code> y <code>get_im</code>? ¿Para qué los querría usar?
        <span class="fragment"><hr/>¿Sólo para imprimir esa información?</span>
        <span class="fragment"><hr/>Sería mejor que fueran privados</span>
    </section>

    <section data-markdown>
        <script type="text/template">
Operador `<<` (`friend`)

```cpp[3-13|12|15-18]
#include <iostream>

class ComplexNumber {
    private:
        float real;
        float im;

    public:
        ComplexNumber(): real{0}, im{0} {};
        ComplexNumber(float real, float im) : real{real}, im{im} {};

        friend std::ostream& operator<<(std::ostream& os, const ComplexNumber& number);
};

std::ostream& operator<<(std::ostream& os, const ComplexNumber& number) {
    os << number.real << " + " << number.im << "i";
    return os;
}

int main() {
    ComplexNumber a{10, 20};
    std::cout << a << std::endl;
}
```
        </script>
    </section>

    <section>
        <h4><code>friend</code> + encapsulamiento + sobrecarga</h4>
        <img src="slides/eda2.0/images/friend-zone-icon.png" class="">
    </section>
</section>



<section data-transition="convex">
    <section data-background="slides/eda2.0/images/backtothefutureII.jpg">
        <h4 class="fragment box-shadow-black">EDA 2.0</h4>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Algoritmos de ordenación</h2>
    </section>

    <section data-menu-title="Bubble sort" data-background="images/bubble-sort-background.jpg">
        <div class="credit white">Imagen: <a
                href="https://www.coindesk.com/bank-of-america-bitcoin-bubble-is-already-popping">Coinbase</a></div>
        <h4>Método de la burbuja</h4>
    </section>

    <section data-markdown data-transition="none-out">
        <script type="text/template">
`std::vector<int>`
```cpp
///hide
#include <iostream>
#include <vector>

///unhide
void bubble_sort(std::vector<int>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
///hide
int main() {
    std::vector<int> elements{9, 8, 7, 6, 5, 4, 3, 2, 1};
    bubble_sort(elements);
    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
```
        </script>
    </section>

    <section data-markdown data-transition="none-in">
        <script type="text/template">
`std::vector<float>`
```cpp
///hide
#include <iostream>
#include <vector>

///unhide
void bubble_sort(std::vector<float>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
///hide
int main() {
    std::vector<float> elements{9.f, 8.f, 7.f, 6.f, 5.f, 4.f, 3.f, 2.f, 1.f};
    bubble_sort(elements);
    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
```
        </script>
    </section>

    <section>
        <p>
            No hay que cambiar prácticamente nada para ordenar vectores de <code>float</code>, 
            de <code>int</code>,... de <span class="red">tipos básicos de datos</span>.
        </p>
        <p>
            El compilador ya sabe cómo se implementan los operadores básicos: <code>operator&#60;</code>, <code>operator&#62;</code>, <code>operator==</code>,...
        </p>
    </section>

    <section data-markdown>
        <script type="text/template">
            ¿Cómo se implementaría el <code>bubble_sort</code> para un vector de estructuras definidas por el usuario?

```cpp
struct Point {
    float x;
    float y;
};

void bubble_sort(std::vector<Point>& elements);
```

<div class="footnote">Recuerda un poco a un ejercicio de las prácticas.</div>
        </script>
    </section>

    <section data-markdown data-transition="none-out">
        <script type="text/template">
`std::vector<int>`
```cpp
///hide
#include <iostream>
#include <vector>

///unhide
void bubble_sort(std::vector<int>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
///hide
int main() {
    std::vector<int> elements{9, 8, 7, 6, 5, 4, 3, 2, 1};
    bubble_sort(elements);
    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
```
        </script>
    </section>

    <section data-markdown data-transition="none-in none-out">
        <script type="text/template">
`std::vector<float>`
```cpp
///hide
#include <iostream>
#include <vector>

///unhide
void bubble_sort(std::vector<float>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
///hide
int main() {
    std::vector<float> elements{9.f, 8.f, 7.f, 6.f, 5.f, 4.f, 3.f, 2.f, 1.f};
    bubble_sort(elements);
    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
```
        </script>
    </section>

    <section data-markdown data-transition="none-in">
        <script type="text/template">
`std::vector<Point>`
```cpp
///hide
#include <iostream>
#include <vector>

struct Point {
    float x;
    float y;
};

///unhide
void bubble_sort(std::vector<Point>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
///hide
int main() {
    std::vector<Point> elements{Point{1, 0}, Point{2, 3}, Point{7, 8}, Point{0, 0}};
    bubble_sort(elements);
    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
El algoritmo es idéntico, sólo hay que proveer la definición para los
operadores que se utilizan.

```cpp
///hide
#include <iostream>
#include <vector>

struct Point {
    float x;
    float y;
};

///unhide
bool operator>(const Point& lhs, const Point& rhs) {
    // A point is greater than other if the distance to origin is bigger.
    float lhs_mod = (lhs.x * lhs.x) + (lhs.y * lhs.y);
    float rhs_mod = (rhs.x * rhs.x) + (rhs.y * rhs.y);
    return lhs_mod > rhs_mod;
}

///hide
std::ostream& operator<<(std::ostream& os, const Point& point) {
    os << "(" << point.x << ", " << point.y << ")";
    return os;
}

void bubble_sort(std::vector<Point>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            if (elements[k] > elements[k+1]) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}

int main() {
    std::vector<Point> elements{Point{1, 0}, Point{2, 3}, Point{7, 8}, Point{0, 0}};
    bubble_sort(elements);
    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
La alternativa es modificar la implementación del algoritmo para cada tipo de dato 😖 👎 😖 👎 

```cpp
void bubble_sort(std::vector<Point>& elements) {
    for (int i=0; i<elements.size()-1; i++) {  // 'n-1' iterations
        for (int k=0; k<elements.size()-1; k++) {  // 'n-1' iterations
            float lhs_mod = (elements[k].x * elements[k].x) + (elements[k].y * elements[k].y);
            float rhs_mod = (elements[k+1].x * elements[k+1].x) + (elements[k+1].y * elements[k+1].y);
            if (lhs_mod > rhs_mod) { // compare adyacent values
                std::swap(elements[k], elements[k+1]);
            }
        }
    }
}
```
        </script>
    </section>

    <section data-state="darken" data-menu-title="Quicksort" data-background="images/quicksort-background.jpg">
        <div class="credit white">Imagen: <a href="https://ctcgulf.com/product/recruitment-and-selection">CTC</a></div>
        <h4>Quicksort</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
`std::vector<int>`


```cpp[16-30|1-14|7-8]
///hide
#include <iostream>
#include <vector>

///unhide
// A function to merge two ordered lists
int partition(std::vector<int>& elements, int left_index, int right_index) {
    auto pivot = elements.at(left_index);
    int i = left_index, j = right_index;

    while(true) {
        while( elements.at(i) <= pivot && i < j ) ++i;
        while( elements.at(j) > pivot ) --j;
        if( i >= j ) break;
        std::swap(elements.at(i), elements.at(j));
    }
    std::swap(elements.at(left_index), elements.at(j));
    return j;
}

// Quick-sort algorithm
void quick_sort(std::vector<int>& elements, int left_index, int right_index) {
    // Check for base/trivial case
    if (left_index >= right_index) {
        return;
    }
    else {
        // Compute the pivot
        int pivot_index = partition(elements, left_index, right_index);

        // Apply quick-sort to both sides (pivot is already in place)
        quick_sort(elements, left_index, pivot_index-1);
        quick_sort(elements, pivot_index+1, right_index);
    }
}
///hide

int main() {
    std::vector<int> elements{9, 8, 7, 6, 5, 4, 3, 2, 1};
    quick_sort(elements, 0, elements.size()-1);

    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
``` 
        </script>
    </section>

    <section>
        <p>¿Qué hay que hacer para adaptar el algoritmo <code class="grey">quicksort</code> a nuestro <code class="grey">std::vector&#60;Point&#62;</code>?</p>
        <p class="fragment">NADA</p>
    </section>

    <section data-markdown>
        <script type="text/template">
`std::vector<Point>`


```cpp[16-30|1-14|7-8]
///hide
#include <iostream>
#include <vector>

struct Point {
    float x;
    float y;
};

bool operator<=(const Point& lhs, const Point& rhs) {
    // A point is greater than other if the distance to origin is bigger.
    float lhs_mod = (lhs.x * lhs.x) + (lhs.y * lhs.y);
    float rhs_mod = (rhs.x * rhs.x) + (rhs.y * rhs.y);
    return lhs_mod <= rhs_mod;
}

bool operator>(const Point& lhs, const Point& rhs) {
    return !(lhs <= rhs);
}

std::ostream& operator<<(std::ostream& os, const Point& point) {
    os << "(" << point.x << ", " << point.y << ")";
    return os;
}

///unhide
// A function to merge two ordered lists
int partition(std::vector<Point>& elements, int left_index, int right_index) {
    auto pivot = elements.at(left_index);
    int i = left_index, j = right_index;

    while(true) {
        while( elements.at(i) <= pivot && i < j ) ++i;
        while( elements.at(j) > pivot ) --j;
        if( i >= j ) break;
        std::swap(elements.at(i), elements.at(j));
    }
    std::swap(elements.at(left_index), elements.at(j));
    return j;
}

// Quick-sort algorithm
void quick_sort(std::vector<Point>& elements, int left_index, int right_index) {
    // Check for base/trivial case
    if (left_index >= right_index) {
        return;
    }
    else {
        // Compute the pivot
        int pivot_index = partition(elements, left_index, right_index);

        // Apply quick-sort to both sides (pivot is already in place)
        quick_sort(elements, left_index, pivot_index-1);
        quick_sort(elements, pivot_index+1, right_index);
    }
}
///hide

int main() {
    std::vector<Point> elements{Point{1, 0}, Point{2, 3}, Point{7, 8}, Point{0, 0}};
    quick_sort(elements, 0, elements.size()-1);

    for (auto v: elements) {
        std::cout << v << std::endl;
    }
}
///unhide
``` 

El algoritmo es 100% idéntico
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Es quien provee el tipo de dato el que debe implementar las funciones que utiliza el algoritmo

```cpp
///hide
struct Point {
    float x;
    float y;
};

///unhide
bool operator<=(const Point& lhs, const Point& rhs) {
    // A point is greater than other if the distance to origin is bigger.
    float lhs_mod = (lhs.x * lhs.x) + (lhs.y * lhs.y);
    float rhs_mod = (rhs.x * rhs.x) + (rhs.y * rhs.y);
    return lhs_mod <= rhs_mod;
}

bool operator>(const Point& lhs, const Point& rhs) {
    return !(lhs <= rhs);
}
///hide
std::ostream& operator<<(std::ostream& os, const Point& point) {
    os << "(" << point.x << ", " << point.y << ")";
    return os;
}
///unhide
```
        </script>
    </section>

    <section data-menu-title="" data-background="slides/eda2.0/images/barney-dude.gif">
    </section>

    <section>
        <h4>División de responsabilidades</h4>
        <p>
            El <span class="blue">algoritmo</span> implementa <span class="blue">cómo</span> se 
            realiza la ordenación y qué necesita.
        </p>
        <hr/>
        <p>
            El <span class="red">usuario</span> provee el <span class="red">tipo de dato</span> 
            y la implementación de los <span class="red">operadores</span> que necesita el algoritmo.
        </p>
    </section>

</section>


<section data-transition="convex">
    <section>
        <h2>Listas colas y pilas</h2>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Árboles</h2>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Grafos</h2>
    </section>
</section>

